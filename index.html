<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>AppLift IMU Monitor - Sliding Window Rep Counter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    * { box-sizing: border-box; }
    body { 
      font-family: Arial, sans-serif; 
      padding: 10px; 
      background-color: #f5f5f5; 
      margin: 0;
      -webkit-text-size-adjust: 100%;
    }
    button { 
      padding: 10px 14px; 
      font-size: 13px; 
      margin: 4px; 
      background-color: #007bff; 
      color: white; 
      border: none; 
      border-radius: 6px; 
      cursor: pointer;
      touch-action: manipulation;
      min-height: 38px;
    }
    button:hover { background-color: #0056b3; }
    button:active { transform: scale(0.98); }
    .container { max-width: 1400px; margin: 0 auto; }
    
    h1 {
      font-size: clamp(16px, 4vw, 24px);
      margin: 8px 0 12px 0;
      text-align: center;
    }
    
    /* Controls - Mobile First */
    .controls { 
      margin-bottom: 12px; 
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      justify-content: center;
    }
    .controls button { margin: 0; flex: 1 1 auto; min-width: 100px; max-width: 160px; }
    
    /* Top bar wrapper for desktop */
    .top-bar {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 12px;
    }
    
    .target-reps-container {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: center;
      width: 100%;
    }
    
    .target-reps-container input {
      width: 60px;
      padding: 8px;
      font-size: 14px;
      border: 2px solid #007bff;
      border-radius: 6px;
    }
    
    /* Exercise Setup Section */
    .exercise-setup {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      padding: 12px;
      border-radius: 10px;
      min-height: 180px;
      display: flex;
      flex-direction: column;
    }
    
    .exercise-setup-title {
      color: white;
      font-weight: bold;
      text-align: center;
      margin-bottom: 10px;
      font-size: 14px;
    }
    
    .exercise-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      flex: 1;
    }
    
    .exercise-grid label {
      color: white;
      font-weight: bold;
      font-size: 11px;
      margin-bottom: 3px;
      display: block;
    }
    
    .exercise-grid select,
    .exercise-grid input {
      width: 100%;
      padding: 8px;
      font-size: 11px;
      border-radius: 6px;
      border: none;
      min-height: 36px;
    }
    
    .exercise-info {
      color: white;
      font-size: 10px;
      text-align: center;
      margin-top: 8px;
      opacity: 0.9;
    }
    
    /* ROM Calibration Section - Hidden */
    .rom-calibration {
      display: none;
    }
    
    /* Data Grid */
    .data-grid { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); 
      gap: 8px; 
      margin-bottom: 12px; 
    }
    .data-card { 
      background: white; 
      border: 1px solid #ddd; 
      padding: 10px; 
      border-radius: 8px; 
      box-shadow: 0 1px 3px rgba(0,0,0,0.1); 
    }
    .data-card h3 { 
      margin: 0 0 6px 0; 
      color: #333; 
      font-size: 12px; 
    }
    .data-card p { margin: 3px 0; font-size: 11px; }
    .value { font-size: 14px; font-weight: bold; color: #007bff; }
    
    .status { 
      padding: 4px 8px; 
      border-radius: 4px; 
      font-size: 10px; 
      font-weight: bold; 
      display: inline-block; 
    }
    .status.detecting { background-color: #28a745; color: white; }
    .status.idle { background-color: #6c757d; color: white; }
    
    /* Hero section - Mobile First */
    .hero-section {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 15px;
    }
    
    .hero-rep-card {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 15px 12px;
      border-radius: 12px;
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.3);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      min-height: 180px;
      order: 2;
    }
    
    .hero-rep-card h3 {
      margin: 0 0 4px 0;
      font-size: 14px;
      opacity: 0.9;
    }
    
    .hero-rep-card .rep-value {
      font-size: clamp(36px, 10vw, 48px);
      font-weight: bold;
      line-height: 1;
      margin-bottom: 4px;
      text-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    
    .hero-rep-card .rep-target {
      font-size: 12px;
      opacity: 0.8;
      margin-bottom: 8px;
    }
    
    .hero-chart-container {
      background: white;
      padding: 12px;
      border-radius: 12px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.08);
      border: 2px solid #667eea;
      grid-column: 1 / -1;
      order: 3;
    }
    
    .hero-chart-container h3 {
      margin: 0 0 8px 0;
      color: #333;
      font-size: 14px;
      text-align: center;
    }
    
    .hero-chart-container canvas {
      width: 100% !important;
      height: 280px !important;
    }
    
    .exercise-setup {
      order: 1;
    }
    
    /* Desktop styles */
    @media (min-width: 768px) {
      body { padding: 15px; }
      
      h1 { text-align: left; }
      
      .controls { justify-content: flex-start; margin-bottom: 0; }
      .controls button { flex: 0 0 auto; }
      
      .top-bar {
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
      }
      
      .target-reps-container {
        width: auto;
        justify-content: flex-end;
      }
      
      .data-grid {
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 12px;
      }
      
      .data-card { padding: 12px; }
      .data-card h3 { font-size: 14px; }
      .data-card p { font-size: 13px; }
      .value { font-size: 16px; }
    }
    
    /* Large desktop - 70/30 layout */
    @media (min-width: 1024px) {
      .hero-section {
        display: grid;
        grid-template-columns: 70% 30%;
        grid-template-rows: auto auto;
        gap: 12px;
        align-items: stretch;
      }
      
      .hero-chart-container {
        grid-column: 1;
        grid-row: 1 / 3;
        padding: 18px;
      }
      
      .hero-chart-container canvas {
        height: 380px !important;
        width: 100% !important;
      }
      
      .exercise-setup {
        grid-column: 2;
        grid-row: 1;
        min-height: auto;
        padding: 10px;
      }
      
      .exercise-setup-title {
        font-size: 13px;
        margin-bottom: 8px;
      }
      
      .exercise-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 6px;
      }
      
      .exercise-grid label {
        font-size: 10px;
        margin-bottom: 2px;
      }
      
      .exercise-grid select,
      .exercise-grid input {
        padding: 6px;
        font-size: 10px;
        min-height: 30px;
      }
      
      .exercise-info {
        font-size: 9px;
        margin-top: 6px;
      }
      
      .hero-rep-card {
        grid-column: 2;
        grid-row: 2;
        min-height: auto;
        padding: 15px 12px;
      }
      
      .hero-rep-card .rep-value {
        font-size: 42px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üèãÔ∏è AppLift IMU Monitor</h1>
    
    <div class="top-bar">
      <div class="controls">
        <button onclick="connectToBLE()">üì∂ Connect</button>
        <button onclick="resetRepCount()">üîÑ Reset</button>
        <button onclick="toggleRecording()">‚ñ∂Ô∏è Start Recording</button>
        <button onclick="startNFCLatencyTest()" style="background-color: #17a2b8;">‚ö° NFC Latency Test</button>
        <button onclick="window.location.href='smartphone_imu_test.html'" style="background-color: #6f42c1;">üì± Phone IMU Test</button>
        <button onclick="openROMTestModal()" style="background-color: #e67e22;">üìê ROM Test</button>
      </div>
      
      <div class="target-reps-container">
        <label for="target-reps" style="font-weight: bold;">Target Reps:</label>
        <input type="number" id="target-reps" min="0" max="100" placeholder="‚àû">
        <span style="color: #666; font-size: 12px;">(empty = no limit)</span>
      </div>
    </div>
    
    <!-- Hero Section: Exercise Setup + Rep Count -->
    <div class="hero-section">
      <div class="hero-chart-container">
        <h3>üìä Real-time Acceleration Data</h3>
        <canvas id="accelChart"></canvas>
      </div>
      
      <!-- Exercise & Equipment Selection -->
      <div class="exercise-setup">
        <div class="exercise-setup-title">üèãÔ∏è Exercise Setup</div>
        <div class="exercise-grid">
          <div>
            <label>Participant #</label>
            <input type="number" id="participant-number" min="1" max="999" value="1">
          </div>
          <div>
            <label>Equipment</label>
            <select id="equipment-select">
              <option value="0">Dumbbell</option>
              <option value="1">Barbell</option>
              <option value="2">Weight Stack</option>
            </select>
          </div>
          <div>
            <label>Exercise</label>
            <select id="exercise-select">
              <optgroup label="Dumbbell">
                <option value="0" data-equipment="0">Concentration Curls</option>
                <option value="1" data-equipment="0">Overhead Extension</option>
              </optgroup>
              <optgroup label="Barbell">
                <option value="2" data-equipment="1">Bench Press</option>
                <option value="3" data-equipment="1">Back Squats</option>
              </optgroup>
              <optgroup label="Weight Stack">
                <option value="4" data-equipment="2">Lateral Pulldown</option>
                <option value="5" data-equipment="2">Seated Leg Extension</option>
              </optgroup>
            </select>
          </div>
          <div>
            <label>Quality Label</label>
            <select id="quality-select">
              <option value="0">Clean</option>
              <option value="1">Uncontrolled Movement</option>
              <option value="2">Abrupt Initiation</option>
            </select>
          </div>
        </div>
        <div class="exercise-info" id="exercise-info">
          <span id="equipment-display">Dumbbell (0)</span> | 
          <span id="exercise-display">Concentration Curls (0)</span> | 
          <span id="quality-display">Clean (0)</span>
        </div>
      </div>
      
      <div class="hero-rep-card">
        <h3>üèãÔ∏è Rep Count</h3>
        <p class="rep-value" id="rep-count">0</p>
        <p class="rep-target" id="rep-target-display">Current Set</p>
        <div class="status idle" id="rep-status">Idle</div>
      </div>
    </div>
    
    <div class="data-grid">
      <div class="data-card">
        <h3>Accelerometer (Raw)</h3>
        <p>X: <span class="value" id="accel-x">--</span> m/s¬≤</p>
        <p>Y: <span class="value" id="accel-y">--</span> m/s¬≤</p>
        <p>Z: <span class="value" id="accel-z">--</span> m/s¬≤</p>
        <p>Mag: <span class="value" id="accel-mag">--</span> m/s¬≤</p>
      </div>
      
      <div class="data-card">
        <h3>Accelerometer (Filtered)</h3>
        <p>X: <span class="value" id="accel-x-filtered">--</span> m/s¬≤</p>
        <p>Y: <span class="value" id="accel-y-filtered">--</span> m/s¬≤</p>
        <p>Z: <span class="value" id="accel-z-filtered">--</span> m/s¬≤</p>
        <p>Mag: <span class="value" id="accel-mag-filtered">--</span> m/s¬≤</p>
      </div>
      
      <div class="data-card">
        <h3>Gyroscope</h3>
        <p>X: <span class="value" id="gyro-x">--</span> rad/s</p>
        <p>Y: <span class="value" id="gyro-y">--</span> rad/s</p>
        <p>Z: <span class="value" id="gyro-z">--</span> rad/s</p>
      </div>
    </div>
    
    <div class="data-grid">
      <div class="data-card">
        <h3>Orientation</h3>
        <p>Roll: <span class="value" id="roll">--</span>¬∞</p>
        <p>Pitch: <span class="value" id="pitch">--</span>¬∞</p>
        <p>Yaw: <span class="value" id="yaw">--</span>¬∞</p>
      </div>
      
      <div class="data-card">
        <h3>Quaternion</h3>
        <p>W: <span class="value" id="quat-w">--</span></p>
        <p>X: <span class="value" id="quat-x">--</span></p>
        <p>Y: <span class="value" id="quat-y">--</span></p>
        <p>Z: <span class="value" id="quat-z">--</span></p>
      </div>
      
      <div class="data-card">
        <h3>Rep Detection (Sliding Window)</h3>
        <p>State: <span class="value" id="rep-state">--</span></p>
        <p>Buffer: <span class="value" id="buffer-state">--</span></p>
        <p>RepHeight: <span class="value" id="last-peak">--</span></p>
      </div>
      
      <div class="data-card">
        <h3>Dynamic Thresholds</h3>
        <p>High: <span class="value" id="threshold-high-display">--</span></p>
        <p>Low: <span class="value" id="threshold-low-display">--</span></p>
        <p>Range: <span class="value" id="threshold-range">--</span></p>
      </div>
      
      <div class="data-card">
        <h3>Algorithm Settings</h3>
        <p style="font-size: 12px;">Window: <span class="value" style="font-size: 14px;">1.5s</span> (80% overlap)</p>
        <p style="font-size: 12px;">Min Duration: <span class="value" style="font-size: 14px;">0.5s</span></p>
        <p style="font-size: 12px;">Prominence: <span class="value" style="font-size: 14px;">0.15</span> m/s¬≤</p>
        <p style="font-size: 11px; color: #666; margin-top: 5px;">‚ö° FAST RESPONSE - Auto-reset window</p>
      </div>
      
      <div class="data-card">
        <h3>Statistics</h3>
        <p>Avg Time: <span class="value" id="avg-rep-time">--</span>s</p>
        <p>Last Rep: <span class="value" id="last-rep-time">--</span>s</p>
        <p>Total Time: <span class="value" id="total-time">--</span>s</p>
      </div>
      
      <div class="data-card">
        <h3>üìê Equipment ROM</h3>
        <p>Type: <span class="value" id="rom-type">--</span></p>
        <p>Last Rep: <span class="value" id="rom-last-rep">--</span></p>
        <p>Avg ROM: <span class="value" id="rom-avg">--</span></p>
        <p>Max ROM: <span class="value" id="rom-max">--</span></p>
        <p>Consistency: <span class="value" id="rom-consistency">--</span></p>
      </div>
      
      <div class="data-card">
        <h3>Connection</h3>
        <p>Status: <span class="value" id="connection-status">Disconnected</span></p>
        <p>Samples: <span class="value" id="sample-count">0</span></p>
        <p>Data Rate: <span class="value" id="data-rate">0</span> Hz</p>
      </div>
      
      <div class="data-card">
        <h3>üì± NFC Equipment</h3>
        <p>Current: <span class="value" id="nfc-equipment">None</span></p>
        <p>Last Scan: <span class="value" id="nfc-timestamp">--</span></p>
        <p style="font-size: 12px; color: #666; margin-top: 5px;">Equipment detected via NFC scan</p>
      </div>
  </div>

  <script>
    const SERVICE_UUID = '4fafc201-1fb5-459e-8fcc-c5c9c331914b';
    const CHARACTERISTIC_UUID_IMU = 'beb5483e-36e1-4688-b7f5-ea07361b26a8';

    let device = null;
    let characteristic = null;
    let chart = null;
    let isRecording = false;
    let recordingStartTime = 0;
    let countdownActive = false;
    
    // ROM Calibration state
    let calibration = {
      extended: null,      // Roll angle at extended position
      contracted: null,    // Roll angle at contracted position
      rom: null,           // Calculated ROM in degrees
      exercise: 'concentration_curls',
      timestamp: null
    };
    let currentRoll = 0;   // Current roll value for calibration
    let calibrationHoldTimer = null;
    let calibrationHoldProgress = 0;
    let calibrationHoldType = null; // 'extended' or 'contracted'
    let calibrationRollSamples = []; // Store samples during 3s hold
    
    // NFC Latency Test state
    let nfcLatencyTestActive = false;
    let nfcTestStartTime = 0;
    let nfcLatencyResults = [];
    
    // Exercise and Equipment mapping
    const EQUIPMENT_MAPPING = {
      0: 'Dumbbell',
      1: 'Barbell',
      2: 'Weight Stack'
    };
    
    const EXERCISE_MAPPING = {
      0: 'Concentration Curls',
      1: 'Overhead Extension',
      2: 'Bench Press',
      3: 'Back Squats',
      4: 'Lateral Pulldown',
      5: 'Seated Leg Extension'
    };
    
    // Movement Quality Labels mapping
    const QUALITY_LABELS = {
      // Dumbbell exercises
      0: ['Clean', 'Uncontrolled Movement', 'Abrupt Initiation'], // Concentration Curls
      1: ['Clean', 'Uncontrolled Movement', 'Abrupt Initiation'], // Single-Arm Overhead Extension
      // Barbell exercises  
      2: ['Clean', 'Uncontrolled Movement', 'Inclination Asymmetry'], // Flat Bench Barbell Press
      3: ['Clean', 'Uncontrolled Movement', 'Inclination Asymmetry'], // Back Squat
      // Weight Stack exercises
      4: ['Clean', 'Pulling Too Fast', 'Releasing Too Fast'], // Lateral Pulldown
      5: ['Clean', 'Pulling Too Fast', 'Releasing Too Fast']  // Seated Leg Extension
    };
    
    // Current selected equipment and exercise
    let selectedEquipment = 0;
    let selectedExercise = 0;
    let selectedQualityLabel = 0; // Default to first quality label (Clean)
    
    // Target reps for auto-stop (0 or empty = no limit)
    function getTargetReps() {
      const input = document.getElementById('target-reps');
      const value = parseInt(input.value);
      return isNaN(value) || value <= 0 ? null : value;
    }
    
    // Raw data logging for CSV export
    let rawDataLog = [];
    
    // Data buffers
    const MAX_CHART_POINTS = 100; // Show last 5 seconds at 20Hz
    const timeData = [];
    const accelMagData = [];
    const accelMagFilteredData = [];
    const accelZData = [];
    const accelZFilteredData = [];
    
    // Kalman Filter for each axis
    class KalmanFilter {
      constructor(processNoise = 0.01, measurementNoise = 0.25, estimationError = 1, initialValue = 0) {
        this.processNoise = processNoise;          // Q - Process noise covariance
        this.measurementNoise = measurementNoise;  // R - Measurement noise covariance
        this.estimationError = estimationError;    // P - Estimation error covariance
        this.value = initialValue;                 // X - Estimated value
      }
      
      update(measurement) {
        // Prediction update
        this.estimationError += this.processNoise;
        
        // Measurement update
        const kalmanGain = this.estimationError / (this.estimationError + this.measurementNoise);
        this.value += kalmanGain * (measurement - this.value);
        this.estimationError = (1 - kalmanGain) * this.estimationError;
        
        return this.value;
      }
    }
    
    // Create Kalman filters for each axis
    const kalmanX = new KalmanFilter(0.01, 0.5, 1, 0);
    const kalmanY = new KalmanFilter(0.01, 0.5, 1, 0);
    const kalmanZ = new KalmanFilter(0.01, 0.5, 1, 9.81); // Standard measurement noise for Z-axis
    
    // Improved Rep Counter with Sliding Window for Slow Controlled Reps
    class RepCounter {
      constructor() {
        this.repCount = 0;
        
        // Sliding window parameters (optimized for fast response)
        this.windowDuration = 1.5; // 1.5 second window for faster detection
        this.windowOverlap = 0.9; // 80% overlap - process almost every sample
        this.samplingRate = 20; // 20Hz
        this.windowSamples = Math.floor(this.windowDuration * this.samplingRate);
        this.stepSize = Math.floor(this.windowSamples * (1 - this.windowOverlap));
        
        // Data buffers
        this.accelBuffer = [];
        this.timeBuffer = [];
        this.allSamples = [];
        
        // Rep segmentation
        this.reps = []; // Array of rep segments with timestamps
        this.currentRep = null;
        this.lastRepEndTime = 0;
        
        // Peak detection for slow movements (VERY sensitive)
        this.minPeakProminence = 0.15; // For m/s¬≤ units
        this.minPeakDistance = 15; // Minimum 0.75s between peaks (20Hz * 0.75) - one rep cycle
        this.minRepDuration = 0.0; // No minimum duration - allow any speed
        this.maxRepDuration = 12.0; // Maximum 12 seconds per rep
        this.adaptiveThreshold = true; // Use adaptive thresholding
        
        // Dynamic threshold (in m/s¬≤ - gravity ‚âà 9.81 m/s¬≤)
        this.thresholdHigh = 10.5;
        this.thresholdLow = 9.5;
        this.repHeight = 0;
        
        // State tracking
        this.state = 'IDLE';
        this.lastPeakIndex = -1;
        this.lastValleyIndex = -1;
        this.lastDetectedValleyIndex = -1; // Track the last valley used in a rep
        this.lastDetectedPeakIndex = -1;   // Track the last peak used in a rep
        this.previousRepEndValley = null;  // Track where the previous rep ended (next rep starts here)
        this.previousRepEndIndex = null;   // Track the sample index where previous rep ended
        this.inRepPhase = false;
        
        // Statistics
        this.repTimes = [];
        this.repStartTime = 0;
      }
      
      addSample(accelX, accelY, accelZ, gyroX, gyroY, gyroZ, roll, pitch, yaw, qw, qx, qy, qz, accelMag, filteredZ, timestamp) {
        // Store complete sample data - rep number will be assigned retroactively when rep is detected
        const sample = {
          timestamp: timestamp,
          accelX, accelY, accelZ,
          gyroX, gyroY, gyroZ,
          roll, pitch, yaw,
          qw, qx, qy, qz,
          accelMag: accelMag,
          sampleIndex: this.allSamples.length, // Track index for retroactive assignment
          repNumber: 0 // Will be assigned when rep boundaries are detected
        };
        
        this.allSamples.push(sample);
        
        // Use filtered magnitude for rep detection on ALL exercises
        this.accelBuffer.push(accelMag);
        this.timeBuffer.push(timestamp);
        
        // Process window immediately when we have enough samples
        if (this.accelBuffer.length >= this.windowSamples) {
          this.processWindow();
        }
      }
      
      processWindow() {
        // Get current window
        const window = this.accelBuffer.slice(-this.windowSamples);
        const windowTimes = this.timeBuffer.slice(-this.windowSamples);
        
        // Calculate statistics EVERY time to prevent threshold drift
        const max = Math.max(...window);
        const min = Math.min(...window);
        const mean = window.reduce((a, b) => a + b, 0) / window.length;
        const range = max - min;
        
        // Calculate standard deviation
        const variance = window.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / window.length;
        const stdDev = Math.sqrt(variance);
        
        // Fixed threshold approach - use minimum threshold to prevent issues with many reps
        // Use 20% of range OR 0.2 m/s¬≤ minimum (more conservative to avoid false positives)
        const rangeThreshold = Math.max(range * 0.20, 0.20);
        const stdThreshold = Math.max(stdDev * 0.6, 0.20);
        const finalThreshold = Math.min(rangeThreshold, stdThreshold);
        
        // Update thresholds EVERY window
        this.thresholdHigh = mean + finalThreshold;
        this.thresholdLow = mean - finalThreshold;
        this.repHeight = range;
        
        // Detect peaks and valleys using prominence-based method
        this.detectRepsInWindow(window, windowTimes);
      }
      
      detectRepsInWindow(window, windowTimes) {
        const n = window.length;
        const currentGlobalIndex = this.accelBuffer.length - 1;
        
        // Find all peaks (local maxima) - 3-sample window for stable detection
        const peaks = [];
        for (let i = 3; i < n - 3; i++) {
          let isPeak = true;
          const centerValue = window[i];
          
          // Check if it's higher than neighbors (3-sample window = stable detection)
          for (let j = i - 3; j <= i + 3; j++) {
            if (j !== i && window[j] >= centerValue) {
              isPeak = false;
              break;
            }
          }
          
          if (isPeak && centerValue > this.thresholdHigh) {
            const globalIndex = currentGlobalIndex - (n - 1 - i);
            
            // Check minimum peak distance to prevent multiple detections in one rep
            if (this.lastPeakIndex === -1 || globalIndex - this.lastPeakIndex >= this.minPeakDistance) {
              peaks.push({
                index: globalIndex,
                value: centerValue,
                time: windowTimes[i]
              });
            }
          }
        }
        
        // Find all valleys (local minima) - 3-sample window for stable detection
        const valleys = [];
        for (let i = 3; i < n - 3; i++) {
          let isValley = true;
          const centerValue = window[i];
          
          // Check if it's lower than neighbors (3-sample window = stable detection)
          for (let j = i - 3; j <= i + 3; j++) {
            if (j !== i && window[j] <= centerValue) {
              isValley = false;
              break;
            }
          }
          
          if (isValley && centerValue < this.thresholdLow) {
            const globalIndex = currentGlobalIndex - (n - 1 - i);
            
            // Check minimum valley distance to prevent multiple detections in one rep
            if (this.lastValleyIndex === -1 || globalIndex - this.lastValleyIndex >= this.minPeakDistance) {
              valleys.push({
                index: globalIndex,
                value: centerValue,
                time: windowTimes[i]
              });
            } 
          }
        }
        
        // Detect rep completion: valley -> peak pattern (1 rep = one cycle)
        // Simple: just need one valley and one peak to count as a rep
        if (valleys.length >= 1 && peaks.length >= 1) {
          const lastValley = valleys[valleys.length - 1];
          const lastPeak = peaks[peaks.length - 1];
          
          // Determine which came first to decide the direction
          let isValidRep = false;
          let startPoint, endPoint, prominence, repDuration;
          
          // Case 1: Valley -> Peak (lifting up from bottom)
          if (lastValley.index < lastPeak.index) {
            // Skip if we've already counted this peak
            if (lastPeak.index <= this.lastDetectedPeakIndex) {
              return;
            }
            
            startPoint = lastValley;
            endPoint = lastPeak;
            prominence = Math.abs(lastPeak.value - lastValley.value);
            repDuration = (lastPeak.time - lastValley.time) / 1000;
            isValidRep = true;
          }
          // Case 2: Peak -> Valley (lowering down from top)
          else if (lastPeak.index < lastValley.index) {
            // Skip if we've already counted this valley
            if (lastValley.index <= this.lastDetectedValleyIndex) {
              return;
            }
            
            startPoint = lastPeak;
            endPoint = lastValley;
            prominence = Math.abs(lastPeak.value - lastValley.value);
            repDuration = (lastValley.time - lastPeak.time) / 1000;
            isValidRep = true;
          }
          
          if (isValidRep) {
            // Log detection attempt for debugging
            console.log(`üîç Rep candidate: duration=${repDuration.toFixed(2)}s, prominence=${prominence.toFixed(3)} m/s¬≤`);
            
            // Very relaxed validation - catch almost all movements
            if (repDuration >= this.minRepDuration && 
                repDuration <= this.maxRepDuration && 
                prominence >= this.minPeakProminence) {
              
              // Count the rep
              this.completeRep(startPoint, lastPeak, endPoint);
              
              // Mark these indices as used
              this.lastDetectedValleyIndex = lastValley.index;
              this.lastDetectedPeakIndex = lastPeak.index;
              this.lastValleyIndex = lastValley.index;
              this.lastPeakIndex = lastPeak.index;
              this.lastRepEndTime = endPoint.time;
            } else {
              console.log(`‚ùå Failed validation: duration=${repDuration >= this.minRepDuration && repDuration <= this.maxRepDuration}, prominence=${prominence >= this.minPeakProminence} (need ${this.minPeakProminence})`);
            }
          }
        }
        
        // Track rep phase for real-time labeling
        if (valleys.length > 0 && peaks.length === 0) {
          this.inRepPhase = true;
          this.state = 'STARTING'; // Bottom position (valley)
        } else if (peaks.length > 0) {
          this.state = 'LIFTING'; // Moving up to peak or coming down
        } else {
          this.inRepPhase = false;
          this.state = 'REST';
        }
      }
      
      completeRep(startValley, peak, endValley) {
        this.repCount++;
        const duration = (endValley.time - startValley.time) / 1000;
        
        console.log(`‚úÖ REP #${this.repCount} | Duration: ${duration.toFixed(2)}s | Range: ${Math.abs(peak.value - startValley.value).toFixed(2)} m/s¬≤`);
        
        // Compute Equipment ROM for this rep
        if (typeof romComputer !== 'undefined') {
          const repROM = romComputer.completeRep();
          if (repROM) {
            console.log(`üìê Rep #${this.repCount} ${romComputer.getROMLabel()}: ${repROM.romValue.toFixed(1)} ${repROM.unit}`);
          }
        }
        
        // Store rep metadata with precise boundary information
        const repData = {
          repNumber: this.repCount,
          startTime: startValley.time,
          endTime: endValley.time,
          startIndex: startValley.index,
          endIndex: endValley.index,
          duration: duration,
          peakValue: peak.value,
          valleyValue: startValley.value,
          range: Math.abs(peak.value - startValley.value)
        };
        this.reps.push(repData);
        this.repTimes.push(duration);
        
        // *** CRITICAL FIX: Continuous segmentation with NO GAPS ***
        // Rep boundaries: each rep INCLUDES the valley sample at the end
        // The next rep starts at the sample AFTER the valley
        
        let repStartIndex = 0;
        
        if (this.repCount === 1) {
          // First rep: starts from sample 0 (beginning of recording)
          repStartIndex = 0;
        } else if (this.previousRepEndIndex !== null) {
          // Subsequent reps: start at the sample AFTER previous rep's valley
          // This ensures continuous coverage: Rep N ends at valley index X, Rep N+1 starts at X+1
          repStartIndex = this.previousRepEndIndex + 1;
        }
        
        // Find the end index: INCLUDE the end valley sample in this rep
        // The next rep will start at the sample AFTER this valley
        // This ensures continuous coverage with NO GAPS
        let repEndIndex = this.allSamples.length - 1;
        for (let i = 0; i < this.allSamples.length; i++) {
          if (this.allSamples[i].timestamp >= endValley.time) {
            // Include the valley sample in this rep (not i-1, but i)
            repEndIndex = i;
            break;
          }
        }
        
        // Ensure we don't overlap with previous rep
        if (repStartIndex > repEndIndex) {
          repEndIndex = repStartIndex;
        }
        
        console.log(`üìç Rep ${this.repCount} boundaries: sample ${repStartIndex} to ${repEndIndex} (valley at ${endValley.time.toFixed(0)}ms)`);
        
        // Assign rep number to all samples in this range
        for (let i = repStartIndex; i <= repEndIndex; i++) {
          this.allSamples[i].repNumber = this.repCount;
        }
        
        // Update rep data with actual sample indices
        repData.actualStartIndex = repStartIndex;
        repData.actualEndIndex = repEndIndex;
        
        // *** Store this rep's end index for the next rep to continue from ***
        this.previousRepEndIndex = repEndIndex;
        this.previousRepEndValley = endValley;
        
        // Visual feedback
        document.getElementById('rep-status').textContent = `Rep #${this.repCount}`;
        document.getElementById('rep-status').className = 'status detecting';
        
        // Check if target reps reached - auto-stop recording
        const targetReps = getTargetReps();
        if (targetReps !== null && this.repCount >= targetReps) {
          console.log(`üéØ Target of ${targetReps} reps reached! Auto-stopping recording...`);
          document.getElementById('rep-status').textContent = `Target Reached! (${this.repCount}/${targetReps})`;
          document.getElementById('rep-status').className = 'status detecting';
          
          // Auto-stop recording after a short delay to capture final data
          setTimeout(() => {
            if (isRecording) {
              toggleRecording(); // Stop recording
            }
          }, 500);
          return;
        }
        
        setTimeout(() => {
          document.getElementById('rep-status').textContent = 'Recording...';
        }, 300);
      }
      
      getAverageRepTime() {
        if (this.repTimes.length === 0) return 0;
        return this.repTimes.reduce((a, b) => a + b, 0) / this.repTimes.length;
      }
      
      reset() {
        this.repCount = 0;
        this.accelBuffer = [];
        this.timeBuffer = [];
        this.allSamples = [];
        this.reps = [];
        this.currentRep = null;
        this.lastRepEndTime = 0;
        this.repTimes = [];
        this.state = 'IDLE';
        this.lastPeakIndex = -1;
        this.lastValleyIndex = -1;
        this.lastDetectedValleyIndex = -1;
        this.lastDetectedPeakIndex = -1;
        this.previousRepEndValley = null;  // Reset previous rep end valley
        this.previousRepEndIndex = null;   // Reset previous rep end index
        this.inRepPhase = false;
        this.repStartTime = 0;
      }
    }
    
    const repCounter = new RepCounter();
    
    // ============ ROM COMPUTER ============
    class ROMComputer {
      constructor() {
        this.exerciseType = 0;
        this.repROMs = [];
        this.currentRepData = [];
        
        // Angle ROM state (quaternion-based)
        this.baselineQuat = null;       // {w,x,y,z} at neutral
        this.primaryAxis = null;        // auto-detected: 'roll','pitch','yaw'
        this.baselineAngle = null;      // Euler baseline
        
        // Stroke ROM state (improved)
        this.velocity = 0;
        this.displacement = 0;
        this.lastTimestamp = 0;
        this.peakDisplacement = 0;
        this.minDisplacement = 0;
        this.baselineGravity = null;    // calibrated gravity vector {x,y,z} from baseline hold
        this.accelHP = 0;               // high-pass filtered acceleration
        this.accelLP = 0;               // low-pass state for HP filter
        this.stillCounter = 0;          // consecutive near-zero samples
        this.STILL_THRESHOLD = 0.25;    // m/s¬≤ - below this = probably still
        this.STILL_SAMPLES = 4;         // samples below threshold to trigger zero-velocity
        this.MAX_DISPLACEMENT = 3.0;    // meters (300 cm) - hard clamp
        
        // Target ROM & Calibration
        this.targetROM = null;          // target ROM from calibration rep (degrees or cm)
        this.isCalibrationRep = false;  // true during calibration rep
        this.romCalibrated = false;     // true after target ROM is set
        
        // Within-rep tracking (position-independent: max - min within the rep)
        this.repMinAngle = Infinity;    // tracks min angle within current rep
        this.repMaxAngle = -Infinity;   // tracks max angle within current rep
        
        // Auto rep detection for ROM test modal
        this.autoRepEnabled = false;        // set true when ROM test modal is open
        this.repPhase = 'idle';             // 'idle' -> 'rising' -> 'peaked' -> complete
        this.repPeakValue = 0;              // peak trackValue within this rep
        this.repSampleCount = 0;            // samples in current rep
        this.MIN_REP_SAMPLES = 10;          // minimum samples for a valid rep (~0.5s)
        this.REP_RETURN_THRESHOLD = 0.4;    // must return to within 40% of peak ROM to complete rep
        
        // Live tracking for ROM test modal
        this.liveAngleDeg = 0;          // current angle from baseline (degrees)
        this.liveDisplacementCm = 0;    // current displacement (cm)
        this.liveVelocity = 0;
        this.liveFulfillment = 0;       // current rep ROM / targetROM * 100
        this.liveRepROM = 0;            // current rep ROM (max-min so far)
        this.sampleHistory = [];        // last N samples for live chart
        this.maxHistorySize = 200;      // ~10s at 20Hz
      }
      
      getROMType(exerciseCode) {
        return exerciseCode <= 1 ? 'angle' : 'stroke';
      }
      
      setExercise(exerciseCode) {
        this.exerciseType = exerciseCode;
        this.reset();
      }
      
      // ---- Quaternion math helpers ----
      quatConjugate(q) {
        return { w: q.w, x: -q.x, y: -q.y, z: -q.z };
      }
      
      quatMultiply(a, b) {
        return {
          w: a.w*b.w - a.x*b.x - a.y*b.y - a.z*b.z,
          x: a.w*b.x + a.x*b.w + a.y*b.z - a.z*b.y,
          y: a.w*b.y - a.x*b.z + a.y*b.w + a.z*b.x,
          z: a.w*b.z + a.x*b.y - a.y*b.x + a.z*b.w
        };
      }
      
      quatToEuler(q) {
        // Returns {roll, pitch, yaw} in degrees
        const sinr = 2 * (q.w * q.x + q.y * q.z);
        const cosr = 1 - 2 * (q.x * q.x + q.y * q.y);
        const roll = Math.atan2(sinr, cosr) * (180 / Math.PI);
        
        let pitch;
        const sinp = 2 * (q.w * q.y - q.z * q.x);
        if (Math.abs(sinp) >= 1) {
          pitch = Math.sign(sinp) * 90;
        } else {
          pitch = Math.asin(sinp) * (180 / Math.PI);
        }
        
        const siny = 2 * (q.w * q.z + q.x * q.y);
        const cosy = 1 - 2 * (q.y * q.y + q.z * q.z);
        const yaw = Math.atan2(siny, cosy) * (180 / Math.PI);
        
        return { roll, pitch, yaw };
      }
      
      // Angle between two quaternions in degrees
      quatAngleDeg(q1, q2) {
        const dot = q1.w*q2.w + q1.x*q2.x + q1.y*q2.y + q1.z*q2.z;
        const clamped = Math.min(1, Math.max(-1, Math.abs(dot)));
        return 2 * Math.acos(clamped) * (180 / Math.PI);
      }
      
      rotateVector(v, q) {
        const p = { w: 0, x: v.x, y: v.y, z: v.z };
        const r = this.quatMultiply(this.quatMultiply(q, p), this.quatConjugate(q));
        return { x: r.x, y: r.y, z: r.z };
      }
      
      // ---- Main sample entry ----
      addSample(roll, pitch, yaw, qw, qx, qy, qz, accelX, accelY, accelZ, timestamp) {
        const romType = this.getROMType(this.exerciseType);
        const q = { w: qw, x: qx, y: qy, z: qz };
        
        if (romType === 'angle') {
          this.addAngleSample(roll, pitch, yaw, q, timestamp);
        } else {
          this.addStrokeSample(q, accelX, accelY, accelZ, timestamp);
        }
      }
      
      // ---- ANGLE ROM (Quaternion-based) ----
      addAngleSample(roll, pitch, yaw, q, timestamp) {
        // Set baseline on first sample (auto)
        if (this.baselineQuat === null) {
          this.baselineQuat = { ...q };
          this.baselineAngle = { roll, pitch, yaw };
        }
        
        // Compute relative quaternion: q_rel = q_baseline^-1 * q_current
        const qRel = this.quatMultiply(this.quatConjugate(this.baselineQuat), q);
        
        // Total angular displacement from baseline (single scalar, degrees)
        this.liveAngleDeg = this.quatAngleDeg(this.baselineQuat, q);
        
        // Also compute per-axis delta for auto-axis detection
        const deltaRoll = roll - this.baselineAngle.roll;
        const deltaPitch = pitch - this.baselineAngle.pitch;
        const deltaYaw = yaw - this.baselineAngle.yaw;
        
        // Track within-rep range (for position-independent ROM)
        // Use primary axis if known, else use total angle
        let trackValue = this.liveAngleDeg;
        if (this.primaryAxis) {
          const axisMap = { roll: deltaRoll, pitch: deltaPitch, yaw: deltaYaw };
          trackValue = axisMap[this.primaryAxis];
        }
        this.repMinAngle = Math.min(this.repMinAngle, trackValue);
        this.repMaxAngle = Math.max(this.repMaxAngle, trackValue);
        this.liveRepROM = this.repMaxAngle - this.repMinAngle;
        
        // Update fulfillment
        if (this.targetROM && this.targetROM > 0) {
          this.liveFulfillment = Math.min(150, (this.liveRepROM / this.targetROM) * 100);
        }
        
        this.currentRepData.push({
          roll: deltaRoll,
          pitch: deltaPitch,
          yaw: deltaYaw,
          totalAngle: this.liveAngleDeg,
          timestamp
        });
        
        // Update live chart history
        this.sampleHistory.push({ t: timestamp, v: this.liveRepROM });
        if (this.sampleHistory.length > this.maxHistorySize) this.sampleHistory.shift();
      }
      
      // ---- STROKE ROM (displacement via quaternion gravity removal) ----
      addStrokeSample(q, accelX, accelY, accelZ, timestamp) {
        // Step 1: Calibrate gravity from first few samples if no baseline
        if (this.baselineGravity === null) {
          // Use current accel reading as gravity reference
          // (should be called during baseline hold when device is still)
          this.baselineGravity = { x: accelX, y: accelY, z: accelZ };
          this.baselineQuat = { ...q };
          this.lastTimestamp = timestamp;
          return;
        }
        
        // Step 2: Remove gravity using quaternion rotation
        // Rotate the calibrated gravity vector from baseline orientation to current orientation
        // g_current = q_current * (q_baseline^-1 * g_baseline * q_baseline) * q_current^-1
        // Simplified: rotate baseline gravity to world, then world to current sensor frame
        const gBaseSensor = this.baselineGravity;
        const gWorld = this.rotateVector(gBaseSensor, this.baselineQuat); // gravity in world frame
        const gCurrent = this.rotateVector(gWorld, this.quatConjugate(q)); // gravity in current sensor frame
        
        // Linear acceleration = measured - expected gravity
        const linX = accelX - gCurrent.x;
        const linY = accelY - gCurrent.y;
        const linZ = accelZ - gCurrent.z;
        
        // Step 3: Rotate linear acceleration to world frame
        const worldAccel = this.rotateVector({ x: linX, y: linY, z: linZ }, q);
        
        // Step 4: Use world Z (vertical axis) for 1D displacement
        const rawAccelZ = worldAccel.z;
        
        if (this.lastTimestamp > 0) {
          const dt = (timestamp - this.lastTimestamp) / 1000;
          if (dt > 0 && dt < 0.5) {
            // High-pass filter: remove DC bias / residual gravity
            // HP = signal - LP(signal), with LP alpha = 0.15 (slow-moving average)
            const lpAlpha = 0.15;
            this.accelLP = lpAlpha * rawAccelZ + (1 - lpAlpha) * this.accelLP;
            this.accelHP = rawAccelZ - this.accelLP;
            
            // Dead-zone: ignore small accelerations (sensor noise)
            let accelInput = Math.abs(this.accelHP) < this.STILL_THRESHOLD ? 0 : this.accelHP;
            
            // Zero-velocity detection: if acceleration stays near zero, force velocity = 0
            if (Math.abs(this.accelHP) < this.STILL_THRESHOLD) {
              this.stillCounter++;
            } else {
              this.stillCounter = 0;
            }
            
            if (this.stillCounter >= this.STILL_SAMPLES) {
              // Device is stationary ‚Äî zero velocity to stop drift
              this.velocity *= 0.5; // rapid decay instead of instant zero for smoothness
              if (Math.abs(this.velocity) < 0.005) this.velocity = 0;
            }
            
            // Integrate: velocity (m/s)
            this.velocity += accelInput * dt;
            
            // Constant velocity decay to counteract drift (~2% per sample)
            this.velocity *= 0.98;
            
            // Integrate: displacement (meters)
            this.displacement += this.velocity * dt;
            
            // Hard clamp to prevent runaway
            this.displacement = Math.max(-this.MAX_DISPLACEMENT, Math.min(this.MAX_DISPLACEMENT, this.displacement));
            
            this.peakDisplacement = Math.max(this.peakDisplacement, this.displacement);
            this.minDisplacement = Math.min(this.minDisplacement, this.displacement);
          }
        }
        this.lastTimestamp = timestamp;
        
        this.liveDisplacementCm = this.displacement * 100;
        this.liveVelocity = this.velocity;
        
        // Track within-rep displacement range
        this.repMinAngle = Math.min(this.repMinAngle, this.liveDisplacementCm);
        this.repMaxAngle = Math.max(this.repMaxAngle, this.liveDisplacementCm);
        this.liveRepROM = this.repMaxAngle - this.repMinAngle;
        
        // Update fulfillment
        if (this.targetROM && this.targetROM > 0) {
          this.liveFulfillment = Math.min(150, (this.liveRepROM / this.targetROM) * 100);
        }
        
        // Auto rep detection (for ROM test modal)
        if (this.autoRepEnabled && !this.isCalibrationRep) {
          this.repSampleCount++;
          this._detectRepBoundary(this.liveRepROM);
        }
        
        this.currentRepData.push({
          displacement: this.liveDisplacementCm,
          velocity: this.velocity,
          timestamp
        });
        
        // Update live chart history
        this.sampleHistory.push({ t: timestamp, v: this.liveRepROM });
        if (this.sampleHistory.length > this.maxHistorySize) this.sampleHistory.shift();
      }
      
      // ---- Auto rep boundary detection ----
      // Detects when ROM rises significantly then returns near starting position
      _detectRepBoundary(currentRepROM) {
        const minROMForRep = this.targetROM ? this.targetROM * 0.3 : 15; // at least 30% of target or 15¬∞/cm
        
        if (this.repPhase === 'idle') {
          // Start tracking when ROM exceeds minimum threshold
          if (currentRepROM > minROMForRep) {
            this.repPhase = 'rising';
            this.repPeakValue = currentRepROM;
          }
        } else if (this.repPhase === 'rising') {
          // Track peak
          if (currentRepROM > this.repPeakValue) {
            this.repPeakValue = currentRepROM;
          }
          // Check if we've started returning (dropped from peak)
          if (currentRepROM < this.repPeakValue * 0.85 && this.repPeakValue > minROMForRep) {
            this.repPhase = 'returning';
          }
        } else if (this.repPhase === 'returning') {
          // Track if peak increases again (not yet returning)
          if (currentRepROM > this.repPeakValue) {
            this.repPeakValue = currentRepROM;
            this.repPhase = 'rising';
            return;
          }
          // Check if returned enough to call it a rep
          // Use current position relative to baseline (not repROM, which never decreases):
          //   - Angle ROM: liveAngleDeg = current angle from baseline
          //   - Stroke ROM: liveDisplacementCm = current vertical displacement
          const romType = this.getROMType(this.exerciseType);
          let currentPos;
          if (romType === 'angle') {
            currentPos = this.liveAngleDeg;
          } else {
            currentPos = Math.abs(this.liveDisplacementCm);
          }
          const atRest = currentPos < this.repPeakValue * this.REP_RETURN_THRESHOLD;
          
          if (atRest && this.repSampleCount >= this.MIN_REP_SAMPLES) {
            // Rep complete!
            this.completeRep();
            this.repPhase = 'idle';
            this.repPeakValue = 0;
            this.repSampleCount = 0;
            console.log(`\u{1F4AA} Auto-detected rep #${this.repROMs.length}`);
          }
        }
      }
      
      // ---- Start calibration rep ----
      startCalibrationRep() {
        this.isCalibrationRep = true;
        this.currentRepData = [];
        this.repMinAngle = Infinity;
        this.repMaxAngle = -Infinity;
        this.liveRepROM = 0;
        this.liveFulfillment = 0;
        // Reset stroke state for clean integration
        this.velocity = 0;
        this.displacement = 0;
        this.accelHP = 0;
        this.accelLP = 0;
        this.stillCounter = 0;
        this.peakDisplacement = 0;
        this.minDisplacement = 0;
        console.log('üéØ ROM calibration rep started ‚Äî do one full-range rep!');
      }
      
      // ---- Finish calibration rep ----
      finishCalibrationRep() {
        if (this.currentRepData.length < 5) {
          console.log('‚ö†Ô∏è Not enough data for calibration rep');
          this.isCalibrationRep = false;
          return null;
        }
        
        const romType = this.getROMType(this.exerciseType);
        let romValue;
        
        if (romType === 'angle') {
          romValue = this.computeAngleROM();
        } else {
          romValue = this.computeStrokeROM();
        }
        
        // Also use within-rep tracking as alternative
        const repRangeROM = this.repMaxAngle - this.repMinAngle;
        romValue = Math.max(romValue, repRangeROM);
        
        // Clamp
        romValue = romType === 'angle' ? Math.min(romValue, 360) : Math.min(romValue, 300);
        
        this.targetROM = romValue;
        this.romCalibrated = true;
        this.isCalibrationRep = false;
        
        // Reset for normal tracking
        this.currentRepData = [];
        this.repMinAngle = Infinity;
        this.repMaxAngle = -Infinity;
        this.liveRepROM = 0;
        
        // Reset stroke state
        if (romType === 'stroke') {
          this.velocity = 0;
          this.displacement = 0;
          this.accelHP = 0;
          this.accelLP = 0;
          this.stillCounter = 0;
          this.peakDisplacement = 0;
          this.minDisplacement = 0;
        }
        
        const unit = romType === 'angle' ? '¬∞' : ' cm';
        console.log(`‚úÖ ROM target set: ${this.targetROM.toFixed(1)}${unit}`);
        return this.targetROM;
      }
      
      // ---- Rep completion ----
      completeRep() {
        if (this.currentRepData.length < 3) return null;
        
        const romType = this.getROMType(this.exerciseType);
        let romValue = 0;
        
        if (romType === 'angle') {
          romValue = this.computeAngleROM();
        } else {
          romValue = this.computeStrokeROM();
        }
        
        // Clamp unrealistic values
        romValue = romType === 'angle' ? Math.min(romValue, 360) : Math.min(romValue, 200);
        
        const repROM = {
          repIndex: this.repROMs.length + 1,
          romValue: romValue,
          romType: romType,
          unit: romType === 'angle' ? 'deg' : 'cm',
          fulfillment: this.targetROM ? Math.min(150, (romValue / this.targetROM) * 100) : null
        };
        this.repROMs.push(repROM);
        
        // Zero-velocity reset at rep boundary for stroke
        if (romType === 'stroke') {
          this.velocity = 0;
          this.displacement = 0;
          this.peakDisplacement = 0;
          this.minDisplacement = 0;
          this.accelHP = 0;
          this.accelLP = 0;
          this.stillCounter = 0;
        }
        this.currentRepData = [];
        this.repMinAngle = Infinity;
        this.repMaxAngle = -Infinity;
        this.liveRepROM = 0;
        this.liveFulfillment = 0;
        
        return repROM;
      }
      
      computeAngleROM() {
        if (this.currentRepData.length < 3) return 0;
        
        // Option 1: Use total quaternion angular displacement
        const totalAngles = this.currentRepData.map(d => d.totalAngle);
        const quatROM = Math.max(...totalAngles) - Math.min(...totalAngles);
        
        // Option 2: Auto-detect primary Euler axis (for single-axis exercises)
        if (this.primaryAxis === null) {
          const ranges = {
            roll: Math.max(...this.currentRepData.map(d => d.roll)) - Math.min(...this.currentRepData.map(d => d.roll)),
            pitch: Math.max(...this.currentRepData.map(d => d.pitch)) - Math.min(...this.currentRepData.map(d => d.pitch)),
            yaw: Math.max(...this.currentRepData.map(d => d.yaw)) - Math.min(...this.currentRepData.map(d => d.yaw))
          };
          this.primaryAxis = Object.entries(ranges).sort((a, b) => b[1] - a[1])[0][0];
          console.log(`üìê ROM auto-detected primary axis: ${this.primaryAxis} (range: ${ranges[this.primaryAxis].toFixed(1)}¬∞)`);
        }
        
        const axisValues = this.currentRepData.map(d => d[this.primaryAxis]);
        const axisROM = Math.max(...axisValues) - Math.min(...axisValues);
        
        // Use the larger of quaternion total or primary-axis ROM
        return Math.max(quatROM, axisROM);
      }
      
      computeStrokeROM() {
        if (this.currentRepData.length < 3) return 0;
        const disp = this.currentRepData.map(d => d.displacement);
        return Math.max(...disp) - Math.min(...disp);
      }
      
      getSetStats() {
        if (this.repROMs.length === 0) return null;
        const values = this.repROMs.map(r => r.romValue);
        const avg = values.reduce((a, b) => a + b, 0) / values.length;
        const max = Math.max(...values);
        const stdDev = Math.sqrt(values.reduce((sum, v) => sum + Math.pow(v - avg, 2), 0) / values.length);
        const consistency = avg > 0 ? ((1 - stdDev / avg) * 100) : 100;
        
        // Average fulfillment
        const fulfillments = this.repROMs.filter(r => r.fulfillment !== null).map(r => r.fulfillment);
        const avgFulfillment = fulfillments.length > 0 ? fulfillments.reduce((a, b) => a + b, 0) / fulfillments.length : null;
        
        return {
          avgROM: avg,
          maxROM: max,
          romConsistencyPercent: Math.max(0, Math.min(100, consistency)),
          romType: this.getROMType(this.exerciseType),
          unit: this.getROMType(this.exerciseType) === 'angle' ? 'deg' : 'cm',
          repCount: this.repROMs.length,
          targetROM: this.targetROM,
          avgFulfillment: avgFulfillment
        };
      }
      
      getROMForRep(repNumber) {
        const rom = this.repROMs.find(r => r.repIndex === repNumber);
        return rom ? rom.romValue : 0;
      }
      
      getROMLabel() {
        const romType = this.getROMType(this.exerciseType);
        if (romType === 'angle') return 'Equipment ROM';
        if (this.exerciseType <= 3) return 'Bar Path ROM';
        return 'Stroke Depth';
      }
      
      calibrateBaseline() {
        // Call this to reset baseline to current position
        this.baselineQuat = null;
        this.baselineAngle = null;
        this.baselineGravity = null;
        this.currentRepData = [];
        this.sampleHistory = [];
        this.velocity = 0;
        this.displacement = 0;
        this.accelHP = 0;
        this.accelLP = 0;
        this.stillCounter = 0;
        this.peakDisplacement = 0;
        this.minDisplacement = 0;
        this.liveAngleDeg = 0;
        this.liveDisplacementCm = 0;
        this.repMinAngle = Infinity;
        this.repMaxAngle = -Infinity;
        this.liveRepROM = 0;
        this.liveFulfillment = 0;
        console.log('üìê ROM baseline recalibrated to current position');
      }
      
      reset() {
        this.baselineQuat = null;
        this.baselineAngle = null;
        this.baselineGravity = null;
        this.primaryAxis = null;
        this.repROMs = [];
        this.currentRepData = [];
        this.velocity = 0;
        this.displacement = 0;
        this.lastTimestamp = 0;
        this.peakDisplacement = 0;
        this.minDisplacement = 0;
        this.accelHP = 0;
        this.accelLP = 0;
        this.stillCounter = 0;
        this.liveAngleDeg = 0;
        this.liveDisplacementCm = 0;
        this.liveVelocity = 0;
        this.sampleHistory = [];
        this.targetROM = null;
        this.isCalibrationRep = false;
        this.romCalibrated = false;
        this.repMinAngle = Infinity;
        this.repMaxAngle = -Infinity;
        this.liveRepROM = 0;
        this.liveFulfillment = 0;
        this.autoRepEnabled = false;
        this.repPhase = 'idle';
        this.repPeakValue = 0;
        this.repSampleCount = 0;
      }
    }
    
    const romComputer = new ROMComputer();
    
    // ============ ROM TEST MODAL ============
    let romTestActive = false;
    let romTestChart = null;
    let romTestChartData = { labels: [], values: [] };
    let romTestUpdateInterval = null;
    let romCalibrating = false;
    let romCalibSamples = [];  // collected {qw,qx,qy,qz,roll,pitch,yaw} during calibration
    let romCalibStartTime = 0;
    const ROM_CALIB_DURATION = 3000; // 3 seconds
    
    function openROMTestModal() {
      if (!device || !device.gatt.connected) {
        alert('Please connect to the ESP32 IMU first!');
        return;
      }
      
      romTestActive = true;
      romComputer.reset();
      romComputer.setExercise(selectedExercise);
      romComputer.autoRepEnabled = true;
      
      const romType = romComputer.getROMType(selectedExercise);
      const unit = romType === 'angle' ? '¬∞' : ' cm';
      const label = romComputer.getROMLabel();
      const exerciseName = EXERCISE_MAPPING[selectedExercise];
      const equipName = EQUIPMENT_MAPPING[selectedEquipment];
      
      const overlay = document.createElement('div');
      overlay.id = 'rom-test-overlay';
      overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: #1a1a2e; color: white; z-index: 10000;
        display: flex; flex-direction: column; overflow: auto;
      `;
      
      overlay.innerHTML = `
        <div style="padding: 15px; max-width: 900px; margin: 0 auto; width: 100%;">
          <!-- Header -->
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; flex-wrap: wrap; gap: 8px;">
            <div>
              <h2 style="margin: 0; color: #e67e22; font-size: clamp(18px, 5vw, 24px);">üìê ROM Test Mode</h2>
              <p style="margin: 4px 0 0 0; color: #aaa; font-size: 13px;">${equipName} ‚Äî ${exerciseName} ‚Äî ${label}</p>
            </div>
            <div style="display: flex; gap: 8px; flex-wrap: wrap;">
              <button id="rom-calib-rep-btn" onclick="romTestStartCalibRep()" style="background: #3498db; padding: 10px 16px; font-size: 13px; border: none; border-radius: 8px; color: white; cursor: pointer; min-height: 38px;">üéØ Calibrate (do 1 rep)</button>
              <button onclick="romTestCalibrate()" style="background: #27ae60; padding: 10px 16px; font-size: 13px; border: none; border-radius: 8px; color: white; cursor: pointer; min-height: 38px;">üìå Set Baseline</button>
              <button onclick="closeROMTestModal()" style="background: #e74c3c; padding: 10px 16px; font-size: 13px; border: none; border-radius: 8px; color: white; cursor: pointer; min-height: 38px;">‚úñ Close</button>
            </div>
          </div>
          
          <!-- Live Value -->
          <div style="background: linear-gradient(135deg, #e67e22 0%, #d35400 100%); border-radius: 15px; padding: 20px; text-align: center; margin-bottom: 12px;">
            <div style="font-size: 13px; opacity: 0.9; margin-bottom: 4px;">Live Rep ROM (max ‚àí min within rep)</div>
            <div id="rom-test-live" style="font-size: clamp(40px, 10vw, 60px); font-weight: bold; line-height: 1;">
              0.0<span style="font-size: 0.4em;">${unit}</span>
            </div>
            <!-- Fulfillment bar -->
            <div id="rom-test-fulfillment-container" style="margin-top: 12px; display: none;">
              <div style="display: flex; justify-content: space-between; font-size: 13px; margin-bottom: 4px;">
                <span>ROM Fulfillment</span>
                <span id="rom-test-fulfillment-pct">0%</span>
              </div>
              <div style="background: rgba(0,0,0,0.3); border-radius: 8px; height: 18px; overflow: hidden;">
                <div id="rom-test-fulfillment-bar" style="height: 100%; width: 0%; border-radius: 8px; transition: width 0.2s, background 0.3s; background: #e74c3c;"></div>
              </div>
              <div style="font-size: 11px; opacity: 0.7; margin-top: 4px;">Target: <span id="rom-test-target-val">--</span></div>
            </div>
            <div id="rom-test-calib-status" style="margin-top: 8px; font-size: 13px; color: #ffeaa7;">
              ‚ö†Ô∏è Not calibrated ‚Äî press "üéØ Calibrate" and do 1 full-range rep
            </div>
            <div style="display: flex; justify-content: center; gap: 30px; margin-top: 10px; font-size: 13px;">
              <span>Angle: <span id="rom-test-quat" style="color: #ffeaa7;">--</span></span>
              <span>Norm: <span id="rom-test-norm" style="color: #ffeaa7;">--</span></span>
              ${romType === 'stroke' ? '<span>Vel: <span id="rom-test-vel" style="color: #ffeaa7;">0</span> cm/s</span>' : ''}
            </div>
          </div>
          
          <!-- Chart -->
          <div style="background: rgba(255,255,255,0.05); border-radius: 12px; padding: 15px; margin-bottom: 12px;">
            <canvas id="rom-test-chart" style="width: 100%; height: 200px;"></canvas>
          </div>
          
          <!-- Per-Rep Table + Set Stats -->
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <div style="background: rgba(255,255,255,0.05); border-radius: 12px; padding: 15px;">
              <h3 style="margin: 0 0 10px 0; color: #e67e22; font-size: 15px;">üìä Per-Rep ROM</h3>
              <div id="rom-test-rep-table" style="font-size: 13px; max-height: 200px; overflow-y: auto;">
                <p style="color: #888;">No reps detected yet. Start exercising!</p>
              </div>
            </div>
            <div style="background: rgba(255,255,255,0.05); border-radius: 12px; padding: 15px;">
              <h3 style="margin: 0 0 10px 0; color: #e67e22; font-size: 15px;">üìà Set Statistics</h3>
              <div id="rom-test-stats" style="font-size: 14px;">
                <p>Avg ROM: <span style="color: #e67e22; font-weight: bold;">--</span></p>
                <p>Max ROM: <span style="color: #e67e22; font-weight: bold;">--</span></p>
                <p>Consistency: <span style="color: #e67e22; font-weight: bold;">--</span></p>
                <p>Reps: <span style="color: #e67e22; font-weight: bold;">0</span></p>
              </div>
              <h3 style="margin: 15px 0 8px 0; color: #3498db; font-size: 15px;">üéØ Exercise Info</h3>
              <div style="font-size: 12px; color: #aaa; line-height: 1.8;">
                <p>ROM Type: <strong style="color: white;">${romType === 'angle' ? 'ANGLE ROM' : 'STROKE ROM'}</strong></p>
                <p>Unit: <strong style="color: white;">${romType === 'angle' ? 'Degrees (¬∞)' : 'Centimeters (cm)'}</strong></p>
                <p>Method: <strong style="color: white;">${romType === 'angle' ? 'Quaternion (max‚àímin per rep)' : 'Double integration (max‚àímin per rep)'}</strong></p>
                <p style="margin-top: 8px; color: #f39c12;"><strong>How to calibrate:</strong></p>
                <p>1. Press "üéØ Calibrate"</p>
                <p>2. Do ONE full-range rep</p>
                <p>3. Press "‚úÖ Done" to set target</p>
                <p>4. Every rep shows fulfillment %</p>
                <p style="margin-top: 6px; color: #27ae60;">Position doesn't matter! ROM = range within each rep</p>
              </div>
            </div>
          </div>
        </div>
      `;
      
      document.body.appendChild(overlay);
      
      // Init ROM test chart
      const ctx = document.getElementById('rom-test-chart').getContext('2d');
      romTestChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: romType === 'angle' ? 'Angular Distance (¬∞)' : 'Displacement (cm)',
            data: [],
            borderColor: '#e67e22',
            backgroundColor: 'rgba(230, 126, 34, 0.1)',
            borderWidth: 2,
            pointRadius: 0,
            tension: 0.2,
            fill: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: false,
          scales: {
            x: { display: true, ticks: { color: '#888', maxTicksLimit: 8 }, grid: { color: 'rgba(255,255,255,0.05)' } },
            y: { display: true, ticks: { color: '#888' }, grid: { color: 'rgba(255,255,255,0.1)' }, grace: '10%',
              title: { display: true, text: romType === 'angle' ? 'Degrees (¬∞)' : 'Displacement (cm)', color: '#888' }
            }
          },
          plugins: { legend: { display: false } }
        }
      });
      
      // Start UI update loop
      romTestUpdateInterval = setInterval(updateROMTestUI, 100);
    }
    
    function updateROMTestUI() {
      if (!romTestActive) return;
      
      const romType = romComputer.getROMType(selectedExercise);
      const unit = romType === 'angle' ? '¬∞' : ' cm';
      const liveValue = romComputer.liveRepROM; // within-rep range (max-min)
      
      // Update live value (show rep ROM, not absolute angle)
      const liveEl = document.getElementById('rom-test-live');
      if (liveEl && !romCalibrating && !romComputer.isCalibrationRep) {
        liveEl.innerHTML = `${liveValue.toFixed(1)}<span style="font-size: 0.4em;">${unit}</span>`;
      }
      
      // Update quaternion/angle display
      const quatEl = document.getElementById('rom-test-quat');
      const normEl = document.getElementById('rom-test-norm');
      if (quatEl) {
        quatEl.textContent = `${romComputer.liveAngleDeg.toFixed(1)}¬∞`;
      }
      
      // Update fulfillment bar
      if (romComputer.romCalibrated) {
        const container = document.getElementById('rom-test-fulfillment-container');
        if (container) container.style.display = 'block';
        
        const pctEl = document.getElementById('rom-test-fulfillment-pct');
        const barEl = document.getElementById('rom-test-fulfillment-bar');
        const targetEl = document.getElementById('rom-test-target-val');
        const statusEl = document.getElementById('rom-test-calib-status');
        
        const pct = romComputer.liveFulfillment;
        if (pctEl) pctEl.textContent = `${pct.toFixed(0)}%`;
        if (barEl) {
          barEl.style.width = Math.min(100, pct) + '%';
          barEl.style.background = pct >= 90 ? '#27ae60' : pct >= 70 ? '#f39c12' : '#e74c3c';
        }
        if (targetEl) targetEl.textContent = `${romComputer.targetROM.toFixed(1)}${unit}`;
        if (statusEl) statusEl.innerHTML = `‚úÖ Calibrated ‚Äî Target: <strong>${romComputer.targetROM.toFixed(1)}${unit}</strong>`;
      }
      
      // Update during calibration rep
      if (romComputer.isCalibrationRep) {
        const liveEl2 = document.getElementById('rom-test-live');
        if (liveEl2) {
          liveEl2.innerHTML = `<div style="font-size: 18px; margin-bottom: 4px;">üéØ Calibration Rep</div>
            <span style="font-size: clamp(40px, 10vw, 60px); font-weight: bold;">${liveValue.toFixed(1)}</span>
            <span style="font-size: 0.3em;">${unit}</span>
            <div style="font-size: 14px; margin-top: 8px; color: #ffeaa7;">Do your FULLEST rep, then press "‚úÖ Done"</div>`;
        }
      }
      
      // Update velocity for stroke
      const velEl = document.getElementById('rom-test-vel');
      if (velEl) {
        velEl.textContent = (romComputer.liveVelocity * 100).toFixed(1);
      }
      
      // Update chart
      if (romTestChart && romComputer.sampleHistory.length > 0) {
        const startTime = romComputer.sampleHistory[0].t;
        romTestChart.data.labels = romComputer.sampleHistory.map(s => ((s.t - startTime) / 1000).toFixed(1));
        romTestChart.data.datasets[0].data = romComputer.sampleHistory.map(s => s.v);
        
        // Add target ROM line if calibrated
        if (romComputer.romCalibrated && romTestChart.data.datasets.length === 1) {
          romTestChart.data.datasets.push({
            label: 'Target ROM',
            data: [],
            borderColor: '#e74c3c',
            borderWidth: 1,
            borderDash: [5, 5],
            pointRadius: 0,
            fill: false
          });
        }
        if (romComputer.romCalibrated && romTestChart.data.datasets.length > 1) {
          romTestChart.data.datasets[1].data = romComputer.sampleHistory.map(() => romComputer.targetROM);
        }
        romTestChart.update('none');
      }
      
      // Update per-rep table with fulfillment
      const tableEl = document.getElementById('rom-test-rep-table');
      if (tableEl && romComputer.repROMs.length > 0) {
        let html = '<table style="width: 100%; border-collapse: collapse;">';
        html += '<tr style="border-bottom: 1px solid rgba(255,255,255,0.1);"><th style="text-align: left; padding: 4px; color: #888;">Rep</th><th style="text-align: right; padding: 4px; color: #888;">ROM</th>';
        if (romComputer.romCalibrated) html += '<th style="text-align: right; padding: 4px; color: #888;">%</th>';
        html += '</tr>';
        romComputer.repROMs.forEach(r => {
          const pct = r.fulfillment;
          const pctColor = pct >= 90 ? '#27ae60' : pct >= 70 ? '#f39c12' : '#e74c3c';
          html += `<tr style="border-bottom: 1px solid rgba(255,255,255,0.05);">`;
          html += `<td style="padding: 4px;">#${r.repIndex}</td>`;
          html += `<td style="text-align: right; padding: 4px; color: #e67e22; font-weight: bold;">${r.romValue.toFixed(1)} ${r.unit}</td>`;
          if (romComputer.romCalibrated && pct !== null) {
            html += `<td style="text-align: right; padding: 4px; color: ${pctColor}; font-weight: bold;">${pct.toFixed(0)}%</td>`;
          }
          html += `</tr>`;
        });
        html += '</table>';
        tableEl.innerHTML = html;
      }
      
      // Update set stats with fulfillment
      const statsEl = document.getElementById('rom-test-stats');
      if (statsEl) {
        const stats = romComputer.getSetStats();
        if (stats) {
          let statsHTML = `
            <p>Avg ROM: <span style="color: #e67e22; font-weight: bold;">${stats.avgROM.toFixed(1)}${unit}</span></p>
            <p>Max ROM: <span style="color: #e67e22; font-weight: bold;">${stats.maxROM.toFixed(1)}${unit}</span></p>
            <p>Consistency: <span style="color: ${stats.romConsistencyPercent > 80 ? '#27ae60' : stats.romConsistencyPercent > 60 ? '#f39c12' : '#e74c3c'}; font-weight: bold;">${stats.romConsistencyPercent.toFixed(0)}%</span></p>
            <p>Reps: <span style="color: #e67e22; font-weight: bold;">${stats.repCount}</span></p>`;
          if (stats.avgFulfillment !== null) {
            const fColor = stats.avgFulfillment >= 90 ? '#27ae60' : stats.avgFulfillment >= 70 ? '#f39c12' : '#e74c3c';
            statsHTML += `<p>Avg Fulfillment: <span style="color: ${fColor}; font-weight: bold;">${stats.avgFulfillment.toFixed(0)}%</span></p>`;
            statsHTML += `<p>Target ROM: <span style="color: #3498db; font-weight: bold;">${stats.targetROM.toFixed(1)}${unit}</span></p>`;
          }
          statsEl.innerHTML = statsHTML;
        }
      }
      
      // Update norm display
      if (normEl && romComputer.baselineQuat) {
        normEl.textContent = '‚úì';
        normEl.style.color = '#27ae60';
      }
    }
    
    // ---- ROM Calibration Rep (do 1 full-range rep to set target) ----
    function romTestStartCalibRep() {
      romComputer.startCalibrationRep();
      
      // Change button to "Done"
      const btn = document.getElementById('rom-calib-rep-btn');
      if (btn) {
        btn.textContent = '‚úÖ Done (finish rep)';
        btn.style.background = '#27ae60';
        btn.onclick = romTestFinishCalibRep;
      }
      
      const statusEl = document.getElementById('rom-test-calib-status');
      if (statusEl) statusEl.innerHTML = 'üéØ <strong>Do your fullest rep now!</strong> Press "‚úÖ Done" when finished.';
    }
    
    function romTestFinishCalibRep() {
      const targetROM = romComputer.finishCalibrationRep();
      const romType = romComputer.getROMType(selectedExercise);
      const unit = romType === 'angle' ? '¬∞' : ' cm';
      
      // Restore button
      const btn = document.getElementById('rom-calib-rep-btn');
      if (btn) {
        btn.textContent = 'üéØ Re-Calibrate';
        btn.style.background = '#3498db';
        btn.onclick = romTestStartCalibRep;
      }
      
      if (targetROM === null) {
        const statusEl = document.getElementById('rom-test-calib-status');
        if (statusEl) statusEl.innerHTML = '‚ùå Not enough movement detected. Try again!';
        return;
      }
      
      // Show success
      const liveEl = document.getElementById('rom-test-live');
      if (liveEl) {
        liveEl.innerHTML = `<div style="font-size: 18px;">‚úÖ Target ROM Set!</div>
          <div style="font-size: clamp(40px, 10vw, 60px); font-weight: bold;">${targetROM.toFixed(1)}<span style="font-size: 0.4em;">${unit}</span></div>
          <div style="font-size: 14px; margin-top: 8px; color: #ffeaa7;">Now do your set ‚Äî each rep shows fulfillment %</div>`;
      }
      
      // Reset rep table and stats
      const tableEl = document.getElementById('rom-test-rep-table');
      if (tableEl) tableEl.innerHTML = '<p style="color: #27ae60;">‚úÖ Target set! Start your working set...</p>';
      
      console.log(`‚úÖ ROM calibration complete. Target: ${targetROM.toFixed(1)}${unit}`);
      
      // Restore normal display after 2s
      setTimeout(restoreCalibLiveDisplay, 2000);
    }
    
    function romTestCalibrate() {
      if (romCalibrating) return; // already calibrating
      
      romCalibrating = true;
      romCalibSamples = [];
      romCalibStartTime = Date.now();
      
      // Show calibration overlay inside the modal
      const liveEl = document.getElementById('rom-test-live');
      if (liveEl) {
        liveEl.dataset.originalHTML = liveEl.innerHTML;
        liveEl.innerHTML = `<div style="font-size: 20px;">üéØ Hold still...</div>
          <div id="rom-calib-countdown" style="font-size: clamp(48px, 12vw, 72px); font-weight: bold;">3</div>
          <div style="background: rgba(0,0,0,0.3); border-radius: 8px; height: 12px; margin-top: 10px; overflow: hidden;">
            <div id="rom-calib-bar" style="height: 100%; width: 0%; background: #27ae60; border-radius: 8px; transition: width 0.1s;"></div>
          </div>
          <div id="rom-calib-samples" style="font-size: 13px; margin-top: 6px; opacity: 0.8;">Collecting samples...</div>`;
      }
      
      console.log('üìê ROM calibration started ‚Äî hold position for 3 seconds');
    }
    
    function updateCalibrationProgress(elapsed) {
      const remaining = Math.max(0, Math.ceil((ROM_CALIB_DURATION - elapsed) / 1000));
      const pct = Math.min(100, (elapsed / ROM_CALIB_DURATION) * 100);
      
      const countdownEl = document.getElementById('rom-calib-countdown');
      if (countdownEl) countdownEl.textContent = remaining;
      
      const barEl = document.getElementById('rom-calib-bar');
      if (barEl) barEl.style.width = pct + '%';
      
      const samplesEl = document.getElementById('rom-calib-samples');
      if (samplesEl) samplesEl.textContent = `Collected ${romCalibSamples.length} samples...`;
    }
    
    function finishCalibration() {
      romCalibrating = false;
      
      if (romCalibSamples.length < 5) {
        alert('Not enough samples collected. Ensure the ESP32 is streaming data, then try again.');
        restoreCalibLiveDisplay();
        return;
      }
      
      // Average quaternion components (works well when they're close together)
      let sumW = 0, sumX = 0, sumY = 0, sumZ = 0;
      let sumRoll = 0, sumPitch = 0, sumYaw = 0;
      
      // Ensure consistent hemisphere (flip quats if dot with first is negative)
      const ref = romCalibSamples[0];
      romCalibSamples.forEach(s => {
        const dot = ref.qw*s.qw + ref.qx*s.qx + ref.qy*s.qy + ref.qz*s.qz;
        const sign = dot < 0 ? -1 : 1;
        sumW += s.qw * sign;
        sumX += s.qx * sign;
        sumY += s.qy * sign;
        sumZ += s.qz * sign;
        sumRoll += s.roll;
        sumPitch += s.pitch;
        sumYaw += s.yaw;
      });
      
      const n = romCalibSamples.length;
      const avgQ = { w: sumW/n, x: sumX/n, y: sumY/n, z: sumZ/n };
      // Normalize
      const norm = Math.sqrt(avgQ.w*avgQ.w + avgQ.x*avgQ.x + avgQ.y*avgQ.y + avgQ.z*avgQ.z);
      avgQ.w /= norm; avgQ.x /= norm; avgQ.y /= norm; avgQ.z /= norm;
      
      const avgEuler = { roll: sumRoll/n, pitch: sumPitch/n, yaw: sumYaw/n };
      
      // Set baseline directly on romComputer
      romComputer.baselineQuat = avgQ;
      romComputer.baselineAngle = avgEuler;
      
      // Average accelerometer readings = gravity vector at baseline orientation
      let sumAx = 0, sumAy = 0, sumAz = 0;
      romCalibSamples.forEach(s => { sumAx += s.accelX; sumAy += s.accelY; sumAz += s.accelZ; });
      romComputer.baselineGravity = { x: sumAx/n, y: sumAy/n, z: sumAz/n };
      
      romComputer.currentRepData = [];
      romComputer.sampleHistory = [];
      romComputer.velocity = 0;
      romComputer.displacement = 0;
      romComputer.accelHP = 0;
      romComputer.accelLP = 0;
      romComputer.stillCounter = 0;
      romComputer.peakDisplacement = 0;
      romComputer.minDisplacement = 0;
      romComputer.liveAngleDeg = 0;
      romComputer.liveDisplacementCm = 0;
      romComputer.repROMs = [];
      romComputer.primaryAxis = null;
      
      const gMag = Math.sqrt(romComputer.baselineGravity.x**2 + romComputer.baselineGravity.y**2 + romComputer.baselineGravity.z**2);
      console.log(`üìê ROM baseline set! Averaged ${n} samples. Quat: [${avgQ.w.toFixed(3)}, ${avgQ.x.toFixed(3)}, ${avgQ.y.toFixed(3)}, ${avgQ.z.toFixed(3)}]`);
      console.log(`üìê Euler baseline: Roll=${avgEuler.roll.toFixed(1)}¬∞ Pitch=${avgEuler.pitch.toFixed(1)}¬∞ Yaw=${avgEuler.yaw.toFixed(1)}¬∞`);
      console.log(`üìê Gravity baseline: [${romComputer.baselineGravity.x.toFixed(3)}, ${romComputer.baselineGravity.y.toFixed(3)}, ${romComputer.baselineGravity.z.toFixed(3)}] mag=${gMag.toFixed(3)} m/s¬≤`);
      
      // Show success briefly then restore
      const liveEl = document.getElementById('rom-test-live');
      if (liveEl) {
        liveEl.innerHTML = `<div style="font-size: 20px;">‚úÖ Baseline Set!</div>
          <div style="font-size: 16px; margin-top: 8px;">${n} samples averaged</div>
          <div style="font-size: 13px; margin-top: 4px; opacity: 0.8">Q: [${avgQ.w.toFixed(2)}, ${avgQ.x.toFixed(2)}, ${avgQ.y.toFixed(2)}, ${avgQ.z.toFixed(2)}]</div>
          <div style="font-size: 14px; margin-top: 8px; color: #ffeaa7;">Start exercising now!</div>`;
      }
      
      // Reset rep table & stats
      const tableEl = document.getElementById('rom-test-rep-table');
      if (tableEl) tableEl.innerHTML = '<p style="color: #27ae60;">‚úÖ Baseline set! Start exercising...</p>';
      const statsEl = document.getElementById('rom-test-stats');
      if (statsEl) {
        const unit = romComputer.getROMType(selectedExercise) === 'angle' ? '¬∞' : ' cm';
        statsEl.innerHTML = `
          <p>Avg ROM: <span style="color: #e67e22; font-weight: bold;">--</span></p>
          <p>Max ROM: <span style="color: #e67e22; font-weight: bold;">--</span></p>
          <p>Consistency: <span style="color: #e67e22; font-weight: bold;">--</span></p>
          <p>Reps: <span style="color: #e67e22; font-weight: bold;">0</span></p>
        `;
      }
      
      // After 1.5s, restore normal live display
      setTimeout(restoreCalibLiveDisplay, 1500);
    }
    
    function restoreCalibLiveDisplay() {
      const liveEl = document.getElementById('rom-test-live');
      if (liveEl) {
        const romType = romComputer.getROMType(selectedExercise);
        const unit = romType === 'angle' ? '¬∞' : ' cm';
        liveEl.innerHTML = `0.0<span style="font-size: 0.4em;">${unit}</span>`;
      }
    }
    
    function closeROMTestModal() {
      romTestActive = false;
      romComputer.autoRepEnabled = false;
      if (romTestUpdateInterval) clearInterval(romTestUpdateInterval);
      if (romTestChart) { romTestChart.destroy(); romTestChart = null; }
      const overlay = document.getElementById('rom-test-overlay');
      if (overlay) document.body.removeChild(overlay);
    }
    
    // Sample counting for data rate calculation
    let sampleCount = 0;
    let lastSampleTime = Date.now();
    let dataRate = 0;
    
    // Initialize Chart
    function initChart() {
      const ctx = document.getElementById('accelChart').getContext('2d');
      chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: timeData,
          datasets: [
            {
              label: 'Raw Acceleration Magnitude',
              data: accelMagData,
              borderColor: 'rgba(255, 99, 132, 0.5)',
              backgroundColor: 'rgba(255, 99, 132, 0.1)',
              borderWidth: 2,
              pointRadius: 0,
              tension: 0.1
            },
            {
              label: 'Filtered Acceleration (Kalman)',
              data: accelMagFilteredData,
              borderColor: 'rgba(54, 162, 235, 1)',
              backgroundColor: 'rgba(54, 162, 235, 0.1)',
              borderWidth: 2,
              pointRadius: 0,
              tension: 0.1
            },
            {
              label: 'High Threshold (Peak)',
              data: Array(MAX_CHART_POINTS).fill(repCounter.thresholdHigh),
              borderColor: 'rgba(75, 192, 192, 0.5)',
              borderWidth: 1,
              borderDash: [5, 5],
              pointRadius: 0,
              fill: false
            },
            {
              label: 'Low Threshold (Trough)',
              data: Array(MAX_CHART_POINTS).fill(repCounter.thresholdLow),
              borderColor: 'rgba(255, 159, 64, 0.5)',
              borderWidth: 1,
              borderDash: [5, 5],
              pointRadius: 0,
              fill: false
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: false,
          scales: {
            x: {
              display: true,
              title: {
                display: true,
                text: 'Time (seconds)'
              }
            },
            y: {
              display: true,
              title: {
                display: true,
                text: 'Acceleration (m/s¬≤)'
              },
              // Auto-scale with padding to show all values
              grace: '10%'
            }
          },
          plugins: {
            legend: {
              display: true,
              position: 'top'
            }
          }
        }
      });
      updateChartLabels();
    }
    
    // Update chart labels based on exercise type
    function updateChartLabels() {
      if (!chart) return;
      
      // Always show magnitude labels for all exercises
      chart.data.datasets[0].label = 'Raw Acceleration Magnitude';
      chart.data.datasets[1].label = 'Filtered Acceleration (Kalman)';
      chart.update('none');
    }
    
    // Update chart with new data
    function updateChart() {
      if (chart) {
        // Update labels (time axis)
        chart.data.labels = timeData;
        
        // Always show magnitude data for all exercises
        chart.data.datasets[0].data = accelMagData;
        chart.data.datasets[1].data = accelMagFilteredData;
        chart.data.datasets[2].data = Array(timeData.length).fill(repCounter.thresholdHigh);
        chart.data.datasets[3].data = Array(timeData.length).fill(repCounter.thresholdLow);
        
        chart.update('none'); // 'none' mode for performance
      }
    }

    async function connectToBLE() {
      try {
        console.log('Requesting Bluetooth Device...');
        device = await navigator.bluetooth.requestDevice({
          filters: [{ name: 'AppLift_IMU' }],
          optionalServices: [SERVICE_UUID]
        });

        console.log('Connecting to GATT Server...');
        const server = await device.gatt.connect();

        console.log('Getting Service...');
        const service = await server.getPrimaryService(SERVICE_UUID);

        console.log('Getting Characteristic...');
        characteristic = await service.getCharacteristic(CHARACTERISTIC_UUID_IMU);

        console.log('Starting Notifications...');
        await characteristic.startNotifications();

        characteristic.addEventListener('characteristicvaluechanged', handleIMUData);
        
        // Get NFC equipment characteristic
        try {
          const nfcCharacteristic = await service.getCharacteristic('ceb5483e-36e1-4688-b7f5-ea07361b26a8');
          await nfcCharacteristic.startNotifications();
          nfcCharacteristic.addEventListener('characteristicvaluechanged', handleNFCData);
          console.log('NFC equipment characteristic subscribed!');
        } catch (e) {
          console.warn('NFC characteristic not available:', e);
        }
        
        console.log('Connected! Receiving IMU data...');
        document.getElementById('connection-status').textContent = 'Connected';
        document.getElementById('connection-status').style.color = '#28a745';
        alert('Connected to AppLift_IMU successfully! Press "Start Recording" to begin.');
        
        // Initialize chart if not already done
        if (!chart) {
          initChart();
        }
      } catch (error) {
        console.error('Connection failed:', error);
        document.getElementById('connection-status').textContent = 'Failed';
        document.getElementById('connection-status').style.color = '#dc3545';
        alert('Connection failed: ' + error.message);
      }
    }

    function handleIMUData(event) {
      const value = event.target.value;
      
      // Parse the 56-byte data array (with quaternions)
      const dataView = new DataView(value.buffer);
      
      const imuData = {
        accelX: dataView.getFloat32(0, true),
        accelY: dataView.getFloat32(4, true),
        accelZ: dataView.getFloat32(8, true),
        gyroX: dataView.getFloat32(12, true),
        gyroY: dataView.getFloat32(16, true),
        gyroZ: dataView.getFloat32(20, true),
        roll: dataView.getFloat32(24, true),
        pitch: dataView.getFloat32(28, true),
        yaw: dataView.getFloat32(32, true),
        qw: dataView.getFloat32(36, true),
        qx: dataView.getFloat32(40, true),
        qy: dataView.getFloat32(44, true),
        qz: dataView.getFloat32(48, true),
        timestamp: dataView.getUint32(52, true)
      };
      
      // Calculate acceleration magnitude
      const accelMag = Math.sqrt(
        imuData.accelX * imuData.accelX +
        imuData.accelY * imuData.accelY +
        imuData.accelZ * imuData.accelZ
      );
      
      // Apply Kalman filter to each axis
      const filteredX = kalmanX.update(imuData.accelX);
      const filteredY = kalmanY.update(imuData.accelY);
      const filteredZ = kalmanZ.update(imuData.accelZ);
      
      // Calculate filtered magnitude
      const filteredMag = Math.sqrt(
        filteredX * filteredX +
        filteredY * filteredY +
        filteredZ * filteredZ
      );
      
      // Only process if recording (after countdown)
      if (isRecording && !countdownActive) {
        // Set recording start time on first sample
        if (recordingStartTime === 0) {
          recordingStartTime = imuData.timestamp;
          console.log(`üìç Recording started at timestamp: ${recordingStartTime}`);
        }
        
        // Calculate relative timestamp (milliseconds from start)
        const relativeTime = imuData.timestamp - recordingStartTime;
        
        // Log raw data for CSV export
        rawDataLog.push({
          timestamp: relativeTime,
          accelX: imuData.accelX,
          accelY: imuData.accelY,
          accelZ: imuData.accelZ,
          gyroX: imuData.gyroX,
          gyroY: imuData.gyroY,
          gyroZ: imuData.gyroZ,
          roll: imuData.roll,
          pitch: imuData.pitch,
          yaw: imuData.yaw,
          qw: imuData.qw,
          qx: imuData.qx,
          qy: imuData.qy,
          qz: imuData.qz,
          accelMag: accelMag,
          filteredX: filteredX,
          filteredY: filteredY,
          filteredZ: filteredZ,
          filteredMag: filteredMag
        });
        
        // Update chart data with relative time in seconds.milliseconds format
        const seconds = Math.floor(relativeTime / 1000);
        const milliseconds = relativeTime % 1000;
        const displayTime = `${seconds}.${milliseconds.toString().padStart(3, '0')}`;
        timeData.push(displayTime);
        accelMagData.push(accelMag);
        accelMagFilteredData.push(filteredMag);
        accelZData.push(-imuData.accelZ);
        accelZFilteredData.push(-filteredZ);
        
        // Keep buffer size manageable
        if (timeData.length > MAX_CHART_POINTS) {
          timeData.shift();
          accelMagData.shift();
          accelMagFilteredData.shift();
          accelZData.shift();
          accelZFilteredData.shift();
        }
        
        // Update chart
        updateChart();
        
        // Rep counting with all sensor data
        repCounter.addSample(
          imuData.accelX, imuData.accelY, imuData.accelZ,
          imuData.gyroX, imuData.gyroY, imuData.gyroZ,
          imuData.roll, imuData.pitch, imuData.yaw,
          imuData.qw, imuData.qx, imuData.qy, imuData.qz,
          filteredMag, filteredZ, relativeTime
        );
        
        // Feed ROM computer with orientation and acceleration data
        romComputer.addSample(
          imuData.roll, imuData.pitch, imuData.yaw,
          imuData.qw, imuData.qx, imuData.qy, imuData.qz,
          imuData.accelX, imuData.accelY, imuData.accelZ,
          relativeTime
        );
        
        updateRepStats();
      }
      
      // Feed ROM computer when ROM test modal is active (independent of recording)
      if (romTestActive && !(isRecording && !countdownActive)) {
        romComputer.addSample(
          imuData.roll, imuData.pitch, imuData.yaw,
          imuData.qw, imuData.qx, imuData.qy, imuData.qz,
          imuData.accelX, imuData.accelY, imuData.accelZ,
          imuData.timestamp
        );
      }
      
      // Collect calibration samples when calibrating
      if (romCalibrating) {
        romCalibSamples.push({
          qw: imuData.qw, qx: imuData.qx, qy: imuData.qy, qz: imuData.qz,
          roll: imuData.roll, pitch: imuData.pitch, yaw: imuData.yaw,
          accelX: imuData.accelX, accelY: imuData.accelY, accelZ: imuData.accelZ
        });
        const elapsed = Date.now() - romCalibStartTime;
        updateCalibrationProgress(elapsed);
        if (elapsed >= ROM_CALIB_DURATION) {
          finishCalibration();
        }
      }
      
      // Always update display (even when not recording)
      displayIMUData(imuData, accelMag, filteredX, filteredY, filteredZ, filteredMag);
      
      // Update sample count and data rate
      sampleCount++;
      const now = Date.now();
      if (now - lastSampleTime >= 1000) {
        dataRate = sampleCount;
        sampleCount = 0;
        lastSampleTime = now;
        document.getElementById('data-rate').textContent = dataRate;
      }
      document.getElementById('sample-count').textContent = sampleCount + dataRate * Math.floor((now - lastSampleTime) / 1000);
    }

    function handleNFCData(event) {
      const value = event.target.value;
      const dataView = new DataView(value.buffer);
      
      // Calculate latency if test is active
      let latency = 0;
      if (nfcLatencyTestActive && nfcTestStartTime > 0) {
        latency = Date.now() - nfcTestStartTime;
        nfcLatencyResults.push(latency);
        nfcLatencyTestActive = false; // Stop test after first detection
        console.log(`‚ö° NFC Latency: ${latency}ms`);
      }
      
      // First byte is the length
      const length = dataView.getUint8(0);
      
      // Extract equipment name (remaining bytes)
      let equipmentName = '';
      for (let i = 1; i <= length && i < value.byteLength; i++) {
        equipmentName += String.fromCharCode(dataView.getUint8(i));
      }
      
      console.log('üì° NFC Equipment detected via BLE:', equipmentName);
      
      // Update UI
      document.getElementById('nfc-equipment').textContent = equipmentName;
      const now = new Date();
      document.getElementById('nfc-timestamp').textContent = now.toLocaleTimeString([], { hour12: true });
      
      // Display NFC equipment notification (with latency if test was active)
      if (latency > 0) {
        showNFCLatencyResult(equipmentName, latency);
      } else {
        showNFCNotification(equipmentName);
      }
    }

    function showNFCNotification(equipmentName) {
      // Create notification element
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px 30px;
        border-radius: 10px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        font-size: 18px;
        font-weight: bold;
        z-index: 10000;
        animation: slideIn 0.3s ease-out;
      `;
      
      notification.textContent = `üì± Equipment: ${equipmentName}`;
      
      // Add animation styles
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideIn {
          from {
            transform: translateX(400px);
            opacity: 0;
          }
          to {
            transform: translateX(0);
            opacity: 1;
          }
        }
        @keyframes slideOut {
          from {
            transform: translateX(0);
            opacity: 1;
          }
          to {
            transform: translateX(400px);
            opacity: 0;
          }
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(notification);
      
      // Auto-remove after 3 seconds with fade out
      setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease-in forwards';
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 300);
      }, 3000);
    }

    function showNFCLatencyResult(equipmentName, latency) {
      // Create latency result notification
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        color: white;
        padding: 25px 35px;
        border-radius: 15px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        font-size: 18px;
        font-weight: bold;
        z-index: 10000;
        animation: slideIn 0.3s ease-out;
        min-width: 300px;
        text-align: center;
      `;
      
      // Calculate latency color based on performance
      let latencyColor = '#ffffff';
      if (latency < 100) latencyColor = '#00ff88';
      else if (latency < 200) latencyColor = '#ffff00';
      else latencyColor = '#ff6b6b';
      
      notification.innerHTML = `
        <div style="font-size: 24px; margin-bottom: 10px;">‚ö° NFC Latency Test</div>
        <div style="font-size: 16px; margin-bottom: 5px;">Equipment: ${equipmentName}</div>
        <div style="font-size: 28px; color: ${latencyColor}; font-weight: bold;">${latency}ms</div>
        <div style="font-size: 12px; opacity: 0.9; margin-top: 5px;">
          ${latency < 100 ? 'Excellent!' : latency < 200 ? 'Good' : 'Could be faster'}
        </div>
      `;
      
      document.body.appendChild(notification);
      
      // Auto-remove after 5 seconds
      setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease-in forwards';
        setTimeout(() => {
          if (notification.parentNode) {
            document.body.removeChild(notification);
          }
        }, 300);
      }, 5000);
      
      // Show summary in console
      console.log(`üìä NFC Latency Test Results: ${nfcLatencyResults.length} tests completed`);
      if (nfcLatencyResults.length > 1) {
        const avg = nfcLatencyResults.reduce((a, b) => a + b, 0) / nfcLatencyResults.length;
        const min = Math.min(...nfcLatencyResults);
        const max = Math.max(...nfcLatencyResults);
        console.log(`üìà Average: ${avg.toFixed(1)}ms, Min: ${min}ms, Max: ${max}ms`);
      }
    }

    async function startNFCLatencyTest() {
      if (!device) {
        alert('Please connect to the BLE device first!');
        return;
      }
      
      // Create countdown overlay
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        color: white;
        text-align: center;
      `;
      
      overlay.innerHTML = `
        <div style="font-size: clamp(32px, 8vw, 48px); margin-bottom: 30px; font-weight: bold;">
          ‚ö° NFC Latency Test
        </div>
        <div style="font-size: clamp(18px, 5vw, 24px); margin-bottom: 40px; opacity: 0.9;">
          Get ready to scan your NFC tag...
        </div>
        <div id="nfc-countdown" style="font-size: clamp(100px, 25vw, 180px); font-weight: bold; color: #ffc107;">
          3
        </div>
        <div style="font-size: clamp(16px, 4vw, 20px); margin-top: 40px; opacity: 0.8;">
          Hold your NFC tag ready!
        </div>
      `;
      
      document.body.appendChild(overlay);
      
      const countdown = document.getElementById('nfc-countdown');
      
      // 3-2-1 countdown
      for (let i = 3; i > 0; i--) {
        countdown.textContent = i;
        countdown.style.color = '#ffc107';
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
      
      // GO! and start timing
      countdown.textContent = 'GO!';
      countdown.style.color = '#28a745';
      countdown.style.animation = 'pulse 0.5s ease-out';
      
      // Add pulse animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes pulse {
          0% { transform: scale(1); }
          50% { transform: scale(1.1); }
          100% { transform: scale(1); }
        }
      `;
      document.head.appendChild(style);
      
      // Start latency measurement
      nfcLatencyTestActive = true;
      nfcTestStartTime = Date.now();
      
      console.log('üöÄ NFC Latency test started! Scan your NFC tag now...');
      
      // Show instructions
      setTimeout(() => {
        countdown.textContent = 'SCAN NOW!';
        countdown.style.fontSize = 'clamp(60px, 15vw, 120px)';
        countdown.style.color = '#ff6b6b';
      }, 500);
      
      // Auto-close overlay after 10 seconds if no scan detected
      const timeoutId = setTimeout(() => {
        if (nfcLatencyTestActive) {
          nfcLatencyTestActive = false;
          document.body.removeChild(overlay);
          alert('‚è∞ NFC Latency test timed out. No NFC scan detected within 10 seconds.');
        }
      }, 10000);
      
      // Close overlay when NFC is detected (handled in handleNFCData)
      const checkForCompletion = setInterval(() => {
        if (!nfcLatencyTestActive) {
          clearInterval(checkForCompletion);
          clearTimeout(timeoutId);
          document.body.removeChild(overlay);
        }
      }, 100);
    }

    function displayIMUData(data, accelMag, filteredX, filteredY, filteredZ, filteredMag) {
      // Update raw data
      document.getElementById('accel-x').textContent = data.accelX.toFixed(2);
      document.getElementById('accel-y').textContent = data.accelY.toFixed(2);
      document.getElementById('accel-z').textContent = data.accelZ.toFixed(2);
      document.getElementById('accel-mag').textContent = accelMag.toFixed(2);
      
      // Update filtered data
      document.getElementById('accel-x-filtered').textContent = filteredX.toFixed(2);
      document.getElementById('accel-y-filtered').textContent = filteredY.toFixed(2);
      document.getElementById('accel-z-filtered').textContent = filteredZ.toFixed(2);
      document.getElementById('accel-mag-filtered').textContent = filteredMag.toFixed(2);
      
      // Update gyroscope
      document.getElementById('gyro-x').textContent = data.gyroX.toFixed(2);
      document.getElementById('gyro-y').textContent = data.gyroY.toFixed(2);
      document.getElementById('gyro-z').textContent = data.gyroZ.toFixed(2);
      
      // Update orientation
      document.getElementById('roll').textContent = data.roll.toFixed(2);
      document.getElementById('pitch').textContent = data.pitch.toFixed(2);
      document.getElementById('yaw').textContent = data.yaw.toFixed(2);
      
      // Update quaternion
      document.getElementById('quat-w').textContent = data.qw.toFixed(4);
      document.getElementById('quat-x').textContent = data.qx.toFixed(4);
      document.getElementById('quat-y').textContent = data.qy.toFixed(4);
      document.getElementById('quat-z').textContent = data.qz.toFixed(4);
      
      // Update current roll for calibration
      currentRoll = data.roll;
    }
    
    function updateRepStats() {
      // Update rep count
      document.getElementById('rep-count').textContent = repCounter.repCount;
      
      // Update target display
      const targetReps = getTargetReps();
      if (targetReps !== null) {
        document.getElementById('rep-target-display').textContent = `Target: ${repCounter.repCount}/${targetReps}`;
      } else {
        document.getElementById('rep-target-display').textContent = 'Current Set';
      }
      
      // Update rep detection state
      document.getElementById('rep-state').textContent = repCounter.state;
      document.getElementById('buffer-state').textContent = `${repCounter.accelBuffer.length}/${repCounter.windowSamples}`;
      
      // Update repHeight info
      if (repCounter.repHeight > 0) {
        document.getElementById('last-peak').textContent = repCounter.repHeight.toFixed(2) + ' m/s¬≤';
      }
      
      // Update dynamic threshold display
      document.getElementById('threshold-high-display').textContent = repCounter.thresholdHigh.toFixed(2) + ' m/s¬≤';
      document.getElementById('threshold-low-display').textContent = repCounter.thresholdLow.toFixed(2) + ' m/s¬≤';
      const range = repCounter.thresholdHigh - repCounter.thresholdLow;
      document.getElementById('threshold-range').textContent = range.toFixed(2) + ' m/s¬≤';
      
      // Update timing stats
      const avgTime = repCounter.getAverageRepTime();
      if (avgTime > 0) {
        document.getElementById('avg-rep-time').textContent = avgTime.toFixed(2);
      }
      if (repCounter.repTimes.length > 0) {
        document.getElementById('last-rep-time').textContent = repCounter.repTimes[repCounter.repTimes.length - 1].toFixed(2);
      }
      
      // Update total time (only when recording)
      if (isRecording && !countdownActive && recordingStartTime > 0) {
        const now = Date.now();
        const totalTime = (now - recordingStartTime - (Date.now() - recordingStartTime)) / 1000;
        if (rawDataLog.length > 0) {
          const lastTimestamp = rawDataLog[rawDataLog.length - 1].timestamp;
          document.getElementById('total-time').textContent = (lastTimestamp / 1000).toFixed(1);
        }
      }
      
      // Update Equipment ROM display
      if (typeof romComputer !== 'undefined') {
        const romType = romComputer.getROMType(selectedExercise);
        const unit = romType === 'angle' ? '¬∞' : ' cm';
        document.getElementById('rom-type').textContent = romComputer.getROMLabel();
        
        if (romComputer.repROMs.length > 0) {
          const lastROM = romComputer.repROMs[romComputer.repROMs.length - 1];
          document.getElementById('rom-last-rep').textContent = lastROM.romValue.toFixed(1) + unit;
          
          const stats = romComputer.getSetStats();
          if (stats) {
            document.getElementById('rom-avg').textContent = stats.avgROM.toFixed(1) + unit;
            document.getElementById('rom-max').textContent = stats.maxROM.toFixed(1) + unit;
            document.getElementById('rom-consistency').textContent = stats.romConsistencyPercent.toFixed(0) + '%';
          }
        }
      }
    }
    
    function resetRepCount() {
      repCounter.reset();
      romComputer.reset();
      rawDataLog = [];
      recordingStartTime = 0;
      document.getElementById('rep-count').textContent = '0';
      document.getElementById('rep-target-display').textContent = 'Current Set';
      document.getElementById('rep-state').textContent = '--';
      document.getElementById('buffer-state').textContent = '--';
      document.getElementById('last-peak').textContent = '--';
      document.getElementById('threshold-high-display').textContent = '--';
      document.getElementById('threshold-low-display').textContent = '--';
      document.getElementById('threshold-range').textContent = '--';
      document.getElementById('avg-rep-time').textContent = '--';
      document.getElementById('last-rep-time').textContent = '--';
      document.getElementById('total-time').textContent = '--';
      document.getElementById('rep-status').textContent = 'Reset';
      document.getElementById('rep-status').className = 'status idle';
      document.getElementById('rom-type').textContent = '--';
      document.getElementById('rom-last-rep').textContent = '--';
      document.getElementById('rom-avg').textContent = '--';
      document.getElementById('rom-max').textContent = '--';
      document.getElementById('rom-consistency').textContent = '--';
      console.log('üîÑ Rep counter reset');
    }
    
    async function showCountdown() {
      countdownActive = true;
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        font-size: clamp(80px, 25vw, 150px);
        color: white;
        font-weight: bold;
        text-shadow: 0 4px 20px rgba(0,0,0,0.5);
      `;
      document.body.appendChild(overlay);
      
      for (let i = 3; i > 0; i--) {
        overlay.textContent = i;
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
      
      overlay.textContent = 'GO!';
      await new Promise(resolve => setTimeout(resolve, 500));
      document.body.removeChild(overlay);
      countdownActive = false;
    }
    
    async function exportToCSV() {
      if (rawDataLog.length === 0) {
        alert('No data to export!');
        return;
      }
      
      // *** FINALIZE REP ASSIGNMENTS BEFORE EXPORT ***
      // This ensures all samples have a rep number, including:
      // 1. Initial samples before first rep detection (assign to rep 1)
      // 2. Trailing samples after last rep detection (assign to last rep + 1 if enough data)
      
      const samples = repCounter.allSamples;
      const totalReps = repCounter.repCount;
      
      console.log(`üìä Finalizing ${samples.length} samples with ${totalReps} detected reps...`);
      
      // First pass: assign rep 1 to any early samples that are still rep 0
      // These are samples before the first valley-peak pattern was detected
      let lastAssignedRep = 0;
      for (let i = 0; i < samples.length; i++) {
        if (samples[i].repNumber === 0) {
          // Check if there's a later sample with a rep number
          let foundLaterRep = false;
          for (let j = i + 1; j < samples.length; j++) {
            if (samples[j].repNumber > 0) {
              // Assign this early sample to rep 1 (before any detection)
              samples[i].repNumber = 1;
              foundLaterRep = true;
              break;
            }
          }
          // If no later rep found, assign to the last known rep or 1
          if (!foundLaterRep) {
            samples[i].repNumber = Math.max(1, lastAssignedRep);
          }
        } else {
          lastAssignedRep = samples[i].repNumber;
        }
      }
      
      // Second pass: handle trailing samples (after the last complete rep)
      // Find the last rep's end valley timestamp
      if (repCounter.reps.length > 0) {
        const lastRep = repCounter.reps[repCounter.reps.length - 1];
        const lastRepEndTime = lastRep.endTime;
        
        // Any samples after the last rep's end valley belong to the "next" rep (incomplete)
        // We'll assign them to lastRep + 1 for analysis purposes
        for (let i = samples.length - 1; i >= 0; i--) {
          if (samples[i].timestamp > lastRepEndTime && samples[i].repNumber === 0) {
            samples[i].repNumber = totalReps + 1;
          } else if (samples[i].repNumber > 0) {
            break; // Stop when we hit assigned samples
          }
        }
      }
      
      // Log final assignment summary
      const repCounts = {};
      samples.forEach(s => {
        repCounts[s.repNumber] = (repCounts[s.repNumber] || 0) + 1;
      });
      console.log('üìä Rep distribution:', repCounts);
      
      // Create enriched data with proper rep labeling
      const participantNum = parseInt(document.getElementById('participant-number').value) || 1;
      
      const enrichedData = rawDataLog.map((logEntry, index) => {
        // Get rep number from allSamples (which tracks rep assignment in real-time)
        const sample = repCounter.allSamples[index];
        const repNumber = sample ? sample.repNumber : 1; // Default to rep 1 if not found
        
        // Format timestamp as seconds.milliseconds (e.g., 00.000, 01.523, 12.045)
        const seconds = Math.floor(logEntry.timestamp / 1000);
        const milliseconds = logEntry.timestamp % 1000;
        const formattedTime = `${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
        
        return {
          participant: participantNum,
          rep: repNumber,
          equipment_code: selectedEquipment,
          exercise_code: selectedExercise,
          quality_code: selectedQualityLabel,
          timestamp: formattedTime,
          timestamp_ms: logEntry.timestamp,
          accelX: logEntry.accelX.toFixed(4),
          accelY: logEntry.accelY.toFixed(4),
          accelZ: logEntry.accelZ.toFixed(4),
          accelMag: logEntry.accelMag.toFixed(4),
          gyroX: logEntry.gyroX.toFixed(4),
          gyroY: logEntry.gyroY.toFixed(4),
          gyroZ: logEntry.gyroZ.toFixed(4),
          roll: logEntry.roll.toFixed(2),
          pitch: logEntry.pitch.toFixed(2),
          yaw: logEntry.yaw.toFixed(2),
          qw: logEntry.qw.toFixed(6),
          qx: logEntry.qx.toFixed(6),
          qy: logEntry.qy.toFixed(6),
          qz: logEntry.qz.toFixed(6),
          romValue: romComputer.getROMForRep(repNumber).toFixed(2),
          romType: romComputer.getROMType(selectedExercise),
          romUnit: romComputer.getROMType(selectedExercise) === 'angle' ? 'deg' : 'cm',
          romLabel: romComputer.getROMLabel(),
          filteredX: logEntry.filteredX.toFixed(4),
          filteredY: logEntry.filteredY.toFixed(4),
          filteredZ: logEntry.filteredZ.toFixed(4),
          filteredMag: logEntry.filteredMag.toFixed(4)
        };
      });
      
      // Create CSV header
      const headers = Object.keys(enrichedData[0]);
      let csvContent = headers.join(',') + '\n';
      
      // Add data rows
      enrichedData.forEach(row => {
        csvContent += Object.values(row).join(',') + '\n';
      });
      
      // Get participant number
      const participantNumber = parseInt(document.getElementById('participant-number').value) || 1;
      const participantStr = `P${participantNumber.toString().padStart(3, '0')}`; // P001, P002, etc.
      
      // Create organized filename
      const equipmentName = EQUIPMENT_MAPPING[selectedEquipment].replace(/\s+/g, '_');
      const exerciseName = EXERCISE_MAPPING[selectedExercise].replace(/\s+/g, '_');
      const qualityName = QUALITY_LABELS[selectedExercise][selectedQualityLabel].replace(/\s+/g, '_');
      
      // Track workout number per participant+exercise+quality using localStorage
      const storageKey = `workout_count_${participantNumber}_${selectedEquipment}_${selectedExercise}_${selectedQualityLabel}`;
      let workoutNumber = parseInt(localStorage.getItem(storageKey) || '0') + 1;
      localStorage.setItem(storageKey, workoutNumber.toString());
      
      const now = new Date();
      const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
      
      // New filename format: P001_Dumbbell_Concentration_Curls_Clean_0_01.csv
      const filename = `${participantStr}_${equipmentName}_${exerciseName}_${qualityName}_${selectedQualityLabel}_${workoutNumber.toString().padStart(2, '0')}.csv`;
      
      // Download CSV file
      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
      
      console.log(`üìä Exported ${enrichedData.length} samples (${repCounter.repCount} reps) to CSV`);
      
      // Show success message
      alert(`‚úÖ ${participantStr} Workout #${workoutNumber} Downloaded!\n\n` +
        `üìÑ File: ${filename}\n\n` +
        `üìä Stats:\n` +
        `‚Ä¢ Participant: ${participantStr}\n` +
        `‚Ä¢ ${enrichedData.length} samples\n` +
        `‚Ä¢ ${repCounter.repCount} reps\n` +
        `‚Ä¢ Equipment: ${EQUIPMENT_MAPPING[selectedEquipment]}\n` +
        `‚Ä¢ Exercise: ${EXERCISE_MAPPING[selectedExercise]}\n` +
        `‚Ä¢ Quality: ${QUALITY_LABELS[selectedExercise][selectedQualityLabel]} (${selectedQualityLabel})`);
    }
    
    function exportEquipmentMapping() {
      // Create mapping reference file
      const mapping = {
        equipment_codes: EQUIPMENT_MAPPING,
        exercise_codes: EXERCISE_MAPPING,
        quality_labels: QUALITY_LABELS,
        current_selection: {
          equipment_code: selectedEquipment,
          equipment_name: EQUIPMENT_MAPPING[selectedEquipment],
          exercise_code: selectedExercise,
          exercise_name: EXERCISE_MAPPING[selectedExercise],
          quality_code: selectedQualityLabel,
          quality_name: QUALITY_LABELS[selectedExercise][selectedQualityLabel]
        },
        export_timestamp: new Date().toISOString()
      };
      
      const jsonStr = JSON.stringify(mapping, null, 2);
      const blob = new Blob([jsonStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = 'exercise_equipment_mapping.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      console.log('üìã Equipment/Exercise mapping exported to exercise_equipment_mapping.json');
    }
    
    function showExportModal() {
      return new Promise((resolve) => {
        const overlay = document.createElement('div');
        overlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.7);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 9999;
          padding: 20px;
        `;
        
        const modal = document.createElement('div');
        modal.style.cssText = `
          background: white;
          padding: 25px;
          border-radius: 15px;
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
          text-align: center;
          max-width: 350px;
          width: 100%;
        `;
        
        modal.innerHTML = `
          <h2 style="margin-top: 0; color: #333; font-size: 22px;">‚úÖ Recording Stopped</h2>
          <p style="color: #666; margin: 15px 0; font-size: 16px;">
            You recorded <strong>${repCounter.repCount} reps</strong><br>with <strong>${rawDataLog.length} samples</strong>.
          </p>
          <p style="color: #666; margin: 15px 0; font-size: 14px;">
            Download the CSV file?
          </p>
          <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
            <button id="modal-download" style="
              padding: 15px 24px;
              font-size: 16px;
              background-color: #28a745;
              color: white;
              border: none;
              border-radius: 10px;
              cursor: pointer;
              font-weight: bold;
              min-height: 50px;
            ">üì• Download CSV</button>
            <button id="modal-skip" style="
              padding: 15px 24px;
              font-size: 16px;
              background-color: #6c757d;
              color: white;
              border: none;
              border-radius: 10px;
              cursor: pointer;
              min-height: 50px;
            ">Skip</button>
          </div>
        `;
        
        overlay.appendChild(modal);
        document.body.appendChild(overlay);
        
        document.getElementById('modal-download').addEventListener('click', () => {
          document.body.removeChild(overlay);
          resolve(true);
        });
        
        document.getElementById('modal-skip').addEventListener('click', () => {
          document.body.removeChild(overlay);
          resolve(false);
        });
      });
    }
    
    async function toggleRecording() {
      if (!isRecording) {
        // Starting recording - show countdown first
        const button = document.querySelector('button[onclick="toggleRecording()"]');
        button.disabled = true;
        button.textContent = '‚è≥ Starting...';
        
        await showCountdown();
        
        // Now start actual recording
        isRecording = true;
        recordingStartTime = 0; // Will be set on first sample
        rawDataLog = [];
        repCounter.reset();
        romComputer.reset();
        romComputer.setExercise(selectedExercise);
        
        button.disabled = false;
        button.textContent = '‚èπÔ∏è Stop Recording';
        button.style.backgroundColor = '#dc3545';
        document.getElementById('rep-status').textContent = 'Recording...';
        document.getElementById('rep-status').className = 'status detecting';
        console.log('üî¥ Recording started after countdown');
      } else {
        // Stop recording
        isRecording = false;
        const button = document.querySelector('button[onclick="toggleRecording()"]');
        button.textContent = '‚ñ∂Ô∏è Start Recording';
        button.style.backgroundColor = '#007bff';
        document.getElementById('rep-status').textContent = 'Stopped';
        document.getElementById('rep-status').className = 'status idle';
        console.log('‚èπÔ∏è Recording stopped');
        
        // Show modal to confirm CSV export
        if (rawDataLog.length > 0) {
          const shouldExport = await showExportModal();
          if (shouldExport) {
            exportToCSV();
          } else {
            console.log('üìä CSV export skipped by user');
          }
        }
      }
    }
    
    // Initialize chart on page load
    window.onload = function() {
      initChart();
      
      // Setup exercise/equipment selectors
      const equipmentSelect = document.getElementById('equipment-select');
      const exerciseSelect = document.getElementById('exercise-select');
      const qualitySelect = document.getElementById('quality-select');
      
      equipmentSelect.addEventListener('change', function() {
        selectedEquipment = parseInt(this.value);
        updateExerciseOptions();
        updateQualityOptions();
        updateExerciseDisplay();
      });
      
      exerciseSelect.addEventListener('change', function() {
        selectedExercise = parseInt(this.value);
        const selectedOption = this.options[this.selectedIndex];
        selectedEquipment = parseInt(selectedOption.dataset.equipment);
        equipmentSelect.value = selectedEquipment;
        romComputer.setExercise(selectedExercise);
        updateQualityOptions();
        updateExerciseDisplay();
        updateChartLabels();
      });
      
      qualitySelect.addEventListener('change', function() {
        selectedQualityLabel = parseInt(this.value);
        updateExerciseDisplay();
      });
      
      updateQualityOptions();
      updateExerciseDisplay();
    };
    
    function updateExerciseOptions() {
      const exerciseSelect = document.getElementById('exercise-select');
      const options = exerciseSelect.querySelectorAll('option');
      
      // Filter and select first matching exercise for equipment
      for (let option of options) {
        if (parseInt(option.dataset.equipment) === selectedEquipment) {
          option.selected = true;
          selectedExercise = parseInt(option.value);
          break;
        }
      }
    }
    
    function updateQualityOptions() {
      const qualitySelect = document.getElementById('quality-select');
      const qualityLabels = QUALITY_LABELS[selectedExercise];
      
      // Clear existing options
      qualitySelect.innerHTML = '';
      
      // Add new options for the selected exercise
      qualityLabels.forEach((label, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = label;
        qualitySelect.appendChild(option);
      });
      
      // Reset selected quality to 0 (first option)
      selectedQualityLabel = 0;
      qualitySelect.value = 0;
    }
    
    function updateExerciseDisplay() {
      document.getElementById('equipment-display').textContent = 
        `${EQUIPMENT_MAPPING[selectedEquipment]} (${selectedEquipment})`;
      document.getElementById('exercise-display').textContent = 
        `${EXERCISE_MAPPING[selectedExercise]} (${selectedExercise})`;
      document.getElementById('quality-display').textContent = 
        `${QUALITY_LABELS[selectedExercise][selectedQualityLabel]} (${selectedQualityLabel})`;
    }
    
    // ============ ROM CALIBRATION FUNCTIONS (Modal-based 3-second hold) ============
    
    function startCalibrationModal() {
      if (currentRoll === 0 && !device) {
        alert('Please connect to the IMU device first!');
        return;
      }
      
      // Reset calibration state
      calibration.extended = null;
      calibration.contracted = null;
      calibration.rom = null;
      
      // Create modal overlay
      const overlay = document.createElement('div');
      overlay.id = 'calibration-modal';
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        padding: 20px;
      `;
      
      const modal = document.createElement('div');
      modal.style.cssText = `
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 25px;
        border-radius: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        text-align: center;
        max-width: 400px;
        width: 100%;
        color: white;
      `;
      
      modal.innerHTML = `
        <h2 style="margin: 0 0 15px 0; font-size: clamp(24px, 6vw, 32px);">üìê ROM Calibration</h2>
        <p id="cal-instruction" style="font-size: clamp(16px, 4vw, 20px); margin: 20px 0; min-height: 50px;">
          Step 1: Hold arm <strong>EXTENDED</strong><br>and get ready...
        </p>
        <div id="cal-countdown" style="font-size: clamp(60px, 15vw, 80px); font-weight: bold; margin: 20px 0; color: #ffc107;">
          3
        </div>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <button id="cal-action-btn" style="
            padding: 15px 30px;
            font-size: 18px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            min-height: 50px;
          ">Start Extended Hold</button>
          <button id="cal-cancel-btn" style="
            padding: 12px 25px;
            font-size: 16px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            min-height: 44px;
          ">Cancel</button>
        </div>
      `;
      
      overlay.appendChild(modal);
      document.body.appendChild(overlay);
      
      // Cancel button handler
      document.getElementById('cal-cancel-btn').addEventListener('click', () => {
        if (calibrationHoldTimer) clearInterval(calibrationHoldTimer);
        document.body.removeChild(overlay);
      });
      
      // Start calibration workflow - use a shared state object
      const modalState = { currentStep: 'ready-extended' };
      
      const actionBtnHandler = () => {
        if (modalState.currentStep === 'ready-extended') {
          modalState.currentStep = 'holding-extended';
          startHoldCountdown('extended', overlay, modalState);
        } else if (modalState.currentStep === 'ready-contracted') {
          modalState.currentStep = 'holding-contracted';
          startHoldCountdown('contracted', overlay, modalState);
        } else if (modalState.currentStep === 'complete') {
          saveAndCloseCalibration(overlay);
        }
      };
      
      document.getElementById('cal-action-btn').addEventListener('click', actionBtnHandler);
    }
    
    function startHoldCountdown(type, overlay, modalState) {
      const instruction = document.getElementById('cal-instruction');
      const countdown = document.getElementById('cal-countdown');
      const actionBtn = document.getElementById('cal-action-btn');
      const cancelBtn = document.getElementById('cal-cancel-btn');
      
      actionBtn.disabled = true;
      cancelBtn.disabled = true;
      
      if (type === 'extended') {
        instruction.innerHTML = '<strong>HOLD EXTENDED POSITION</strong><br>Keep your arm still...';
      } else {
        instruction.innerHTML = '<strong>HOLD CONTRACTED POSITION</strong><br>Keep your arm still...';
      }
      
      calibrationHoldProgress = 0;
      calibrationRollSamples = [];
      
      calibrationHoldTimer = setInterval(() => {
        calibrationHoldProgress += 0.1;
        calibrationRollSamples.push(currentRoll);
        
        const remaining = Math.ceil(3 - calibrationHoldProgress);
        countdown.textContent = remaining;
        
        if (calibrationHoldProgress >= 3) {
          clearInterval(calibrationHoldTimer);
          completeCalibrationStep(type, overlay, modalState);
        }
      }, 100);
    }
    
    function completeCalibrationStep(type, overlay, modalState) {
      const avgRoll = calibrationRollSamples.reduce((a, b) => a + b, 0) / calibrationRollSamples.length;
      
      const instruction = document.getElementById('cal-instruction');
      const countdown = document.getElementById('cal-countdown');
      const actionBtn = document.getElementById('cal-action-btn');
      const cancelBtn = document.getElementById('cal-cancel-btn');
      
      if (type === 'extended') {
        calibration.extended = avgRoll;
        document.getElementById('cal-extended-display').textContent = avgRoll.toFixed(1);
        console.log(`üìê Extended: ${avgRoll.toFixed(2)}¬∞ (avg of ${calibrationRollSamples.length} samples)`);
        
        // Show success and move to contracted
        countdown.textContent = '‚úì';
        countdown.style.color = '#28a745';
        instruction.innerHTML = '‚úÖ Extended position recorded!<br><br>Now hold arm <strong>CONTRACTED</strong>';
        actionBtn.textContent = 'Start Contracted Hold';
        actionBtn.disabled = false;
        cancelBtn.disabled = false;
        
        // Update step for next button click
        modalState.currentStep = 'ready-contracted';
        
        // Reset countdown display after a brief pause
        setTimeout(() => {
          countdown.textContent = '3';
          countdown.style.color = '#ffc107';
        }, 1500);
        
      } else {
        calibration.contracted = avgRoll;
        document.getElementById('cal-contracted-display').textContent = avgRoll.toFixed(1);
        calibration.rom = Math.abs(calibration.contracted - calibration.extended);
        document.getElementById('cal-rom-display').textContent = calibration.rom.toFixed(1);
        console.log(`üìê Contracted: ${avgRoll.toFixed(2)}¬∞ (avg of ${calibrationRollSamples.length} samples)`);
        console.log(`üìê ROM: ${calibration.rom.toFixed(2)}¬∞`);
        
        // Show completion
        countdown.textContent = '‚úì';
        countdown.style.color = '#28a745';
        instruction.innerHTML = `‚úÖ Calibration Complete!<br><br>
          Extended: <strong>${calibration.extended.toFixed(1)}¬∞</strong><br>
          Contracted: <strong>${calibration.contracted.toFixed(1)}¬∞</strong><br>
          ROM: <strong style="color: #ffc107;">${calibration.rom.toFixed(1)}¬∞</strong>`;
        actionBtn.textContent = 'üíæ Save & Close';
        actionBtn.disabled = false;
        cancelBtn.disabled = false;
        
        // Update step for final save action
        modalState.currentStep = 'complete';
      }
      
      calibrationRollSamples = [];
    }
    
    function saveAndCloseCalibration(overlay) {
      saveCalibration();
      document.body.removeChild(overlay);
    }
    
    function saveCalibration() {
      if (calibration.extended === null || calibration.contracted === null) {
        alert('Please calibrate both Extended and Contracted positions first!');
        return;
      }
      
      // Prepare calibration data (compatible with rom_analyzer.py)
      calibration.timestamp = new Date().toISOString();
      
      const calibrationData = {
        exercise: EXERCISE_MAPPING[selectedExercise].toLowerCase().replace(/ /g, '_'),
        exercise_code: selectedExercise,
        equipment_code: selectedEquipment,
        roll_extended: calibration.extended,
        roll_contracted: calibration.contracted,
        rom_degrees: calibration.rom,
        calibration_source: 'live_imu_3s_hold',
        timestamp: calibration.timestamp,
        // Additional metadata for analysis
        metadata: {
          device: 'AppLift_IMU',
          method: '3_second_hold',
          equipment_name: EQUIPMENT_MAPPING[selectedEquipment],
          exercise_name: EXERCISE_MAPPING[selectedExercise],
          notes: 'Calibrated via test (1).html with 3-second hold averaging'
        }
      };
      
      // Create and download JSON file
      const jsonStr = JSON.stringify(calibrationData, null, 2);
      const blob = new Blob([jsonStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = 'rom_calibration.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      console.log('üíæ Calibration saved to rom_calibration.json');
      console.log('Calibration data:', calibrationData);
      
      console.log('üíæ Calibration file downloaded successfully');
    }
  </script>
</body>
</html>
